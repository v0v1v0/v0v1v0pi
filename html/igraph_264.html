<div class="container">

<table style="width: 100%;"><tr>
<td>edge.betweenness.community</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Community structure detection based on edge betweenness</h2>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt="[Deprecated]"></a>
</p>
<p><code>edge.betweenness.community()</code> was renamed to <code>cluster_edge_betweenness()</code> to create a more
consistent API.
</p>


<h3>Usage</h3>

<pre><code class="language-R">edge.betweenness.community(
  graph,
  weights = NULL,
  directed = TRUE,
  edge.betweenness = TRUE,
  merges = TRUE,
  bridges = TRUE,
  modularity = TRUE,
  membership = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>graph</code></td>
<td>
<p>The graph to analyze.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>weights</code></td>
<td>
<p>The weights of the edges. It must be a positive numeric vector,
<code>NULL</code> or <code>NA</code>. If it is <code>NULL</code> and the input graph has a
‘weight’ edge attribute, then that attribute will be used. If
<code>NULL</code> and no such attribute is present, then the edges will have equal
weights. Set this to <code>NA</code> if the graph was a ‘weight’ edge
attribute, but you don't want to use it for community detection. Edge weights
are used to calculate weighted edge betweenness. This means that edges are
interpreted as distances, not as connection strengths.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>directed</code></td>
<td>
<p>Logical constant, whether to calculate directed edge
betweenness for directed graphs. It is ignored for undirected graphs.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>edge.betweenness</code></td>
<td>
<p>Logical constant, whether to return the edge
betweenness of the edges at the time of their removal.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>merges</code></td>
<td>
<p>Logical constant, whether to return the merge matrix
representing the hierarchical community structure of the network.  This
argument is called <code>merges</code>, even if the community structure algorithm
itself is divisive and not agglomerative: it builds the tree from top to
bottom. There is one line for each merge (i.e. split) in matrix, the first
line is the first merge (last split). The communities are identified by
integer number starting from one. Community ids smaller than or equal to
<code class="reqn">N</code>, the number of vertices in the graph, belong to singleton
communities, i.e. individual vertices. Before the first merge we have <code class="reqn">N</code>
communities numbered from one to <code class="reqn">N</code>. The first merge, the first line of
the matrix creates community <code class="reqn">N+1</code>, the second merge creates community
<code class="reqn">N+2</code>, etc.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>bridges</code></td>
<td>
<p>Logical constant, whether to return a list the edge removals
which actually splitted a component of the graph.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>modularity</code></td>
<td>
<p>Logical constant, whether to calculate the maximum
modularity score, considering all possibly community structures along the
edge-betweenness based edge removals.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>membership</code></td>
<td>
<p>Logical constant, whether to calculate the membership
vector corresponding to the highest possible modularity score.</p>
</td>
</tr>
</table>
</div>