<div class="container">

<table style="width: 100%;"><tr>
<td>innsight_sugar</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Syntactic sugar for object construction</h2>

<h3>Description</h3>

<p>Since all methods and the preceding conversion step in the <code>innsight</code>
package were implemented using R6 classes and these always require a call
to <code>classname$new()</code> for initialization, the following functions are
defined to shorten the construction of the corresponding R6 objects:
</p>

<ul>
<li> <p><code>convert()</code> for <code>Converter</code>
</p>
</li>
<li> <p><code>run_grad()</code> for <code>Gradient</code>
</p>
</li>
<li> <p><code>run_smoothgrad()</code> for <code>SmoothGrad</code>
</p>
</li>
<li> <p><code>run_intgrad()</code> for <code>IntegratedGradient</code>
</p>
</li>
<li> <p><code>run_expgrad()</code> for <code>ExpectedGradient</code>
</p>
</li>
<li> <p><code>run_lrp()</code> for <code>LRP</code>
</p>
</li>
<li> <p><code>run_deeplift()</code> for <code>DeepLift</code>
</p>
</li>
<li> <p><code>run_deepshap</code> for <code>DeepSHAP</code>
</p>
</li>
<li> <p><code>run_cw</code> for <code>ConnectionWeights</code>
</p>
</li>
<li> <p><code>run_lime</code> for <code>LIME</code>
</p>
</li>
<li> <p><code>run_shap</code> for <code>SHAP</code>
</p>
</li>
</ul>
<h3>Usage</h3>

<pre><code class="language-R"># Create a new `Converter` object of the given `model`
convert(model, ...)

# Apply the `Gradient` method to the passed `data` to be explained
run_grad(converter, data, ...)

# Apply the `SmoothGrad` method to the passed `data` to be explained
run_smoothgrad(converter, data, ...)

# Apply the `IntegratedGradient` method to the passed `data` to be explained
run_intgrad(converter, data, ...)

# Apply the `ExpectedGradient` method to the passed `data` to be explained
run_expgrad(converter, data, ...)

# Apply the `LRP` method to the passed `data` to be explained
run_lrp(converter, data, ...)

# Apply the `DeepLift` method to the passed `data` to be explained
run_deeplift(converter, data, ...)

# Apply the `DeepSHAP` method to the passed `data` to be explained
run_deepshap(converter, data, ...)

# Apply the `ConnectionWeights` method (argument `data` is not always required)
run_cw(converter, ...)

# Apply the `LIME` method to explain `data` by using the dataset `data_ref`
run_lime(model, data, data_ref, ...)

# Apply the `SHAP` method to explain `data` by using the dataset `data_ref`
run_shap(model, data, data_ref, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>model</code></td>
<td>
<p>(<code>nn_sequential</code>, <code>keras_model</code>,
<code>neuralnet</code> or <code>list</code>)<br>
A trained neural network for classification or regression
tasks to be interpreted. Only models from the following types or
packages are allowed: <code>nn_sequential</code>,
<code>keras_model</code>,
<code>keras_model_sequential</code>,
<code>neuralnet</code> or a named list (see details).<br><strong>Note:</strong> For the model-agnostic methods, an arbitrary fitted model for a
classification or regression task can be passed. A <code>Converter</code> object can
also be passed. In order for the package to know how to make predictions
with the given model, a prediction function must also be passed with
the argument <code>pred_fun</code>. However, for models created by
<code>nn_sequential</code>, <code>keras_model</code>,
<code>neuralnet</code> or <code>Converter</code>,
these have already been pre-implemented and do not need to be
specified.<br></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>Other arguments passed to the individual constructor functions
of the methods R6 classes.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>converter</code></td>
<td>
<p>(<code>Converter</code>)<br>
An instance of the <code>Converter</code> class that includes the
torch-converted model and some other model-specific attributes. See
<code>Converter</code> for details.<br></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>data</code></td>
<td>
<p>(<code>array</code>, <code>data.frame</code>, <code>torch_tensor</code> or <code>list</code>)<br>
The data to which the method is to be applied. These must
have the same format as the input data of the passed model to the
converter object. This means either
</p>

<ul>
<li>
<p> an <code>array</code>, <code>data.frame</code>, <code>torch_tensor</code> or array-like format of
size <em>(batch_size, dim_in)</em>, if e.g., the model has only one input layer, or
</p>
</li>
<li>
<p> a <code>list</code> with the corresponding input data (according to the
upper point) for each of the input layers.
</p>
</li>
</ul>
<p><strong>Note:</strong> For the model-agnostic methods, only models with a single
input and output layer is allowed!<br></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>data_ref</code></td>
<td>
<p>(<code>array</code>, <code>data.frame</code> or <code>torch_tensor</code>)<br>
The dataset to which the method is to be applied. These must
have the same format as the input data of the passed model and has to
be either <code>matrix</code>, an <code>array</code>, a <code>data.frame</code> or a
<code>torch_tensor</code>.<br><strong>Note:</strong> For the model-agnostic methods, only models with a single
input and output layer is allowed!<br></p>
</td>
</tr>
</table>
<h3>Value</h3>

<p>R6::R6Class object of the respective type.
</p>


</div>