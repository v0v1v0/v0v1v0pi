<div class="container">

<table style="width: 100%;"><tr>
<td>impimp</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Imprecise Imputation for Statistical Matching</h2>

<h3>Description</h3>

<p>Impute a data frame imprecisely
</p>


<h3>Usage</h3>

<pre><code class="language-R">impimp(recipient, donor, method = c("variable_wise", "case_wise",
  "domain"), matchvars = NULL, vardomains = NULL)

## S3 method for class 'impimp'
print(x, ...)

is.impimp(z)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>recipient</code></td>
<td>
<p>a data.frame acting as recipient; see details.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>donor</code></td>
<td>
<p>a data.frame acting as donor; see details.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>method</code></td>
<td>
<p>1-character string of the desired imputation method.
The following values are possible, see details for an explanantion:
<code>"variable_wise"</code> (default), <code>"case_wise"</code> and
<code>"domain"</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>matchvars</code></td>
<td>
<p>a character vector containing the variable names
to be used as matching variables. If <code>NULL</code> (default) all
variables, present in both <code>donor</code> and <code>recipient</code> are
used as matching variables.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>vardomains</code></td>
<td>
<p>a named list containing the possible values of
all variable in <code>donor</code> that are not present in
<code>recipient</code>.<br>
If set to <code>NULL</code> (default) the list is generated by first
coercing all those variables to type <code>factor</code>
and then storing their levels.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>object of class 'impimp'</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>further arguments passed down to
<code>print.data.frame</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>z</code></td>
<td>
<p>object to test for class <code>"impimp"</code></p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>As in the context of statistical matching the data.frames
<code>recipient</code> and <code>donor</code> are assumed to contain an
overlapping set of variables.
</p>
<p>The missing values in <code>recipient</code> are subsituted with
observed values in <code>donor</code> for approaches based on donation
classes and otherwise with the set of all possible values for
the variable in question.
</p>
<p>For <code>method = "domain"</code> a missing value of a variable in
<code>recipient</code> is imputed by the set of all possible values
of that variable.
</p>
<p>The other methods are based on donation classes which are formed
based on the matching variables whose names are provided by
<code>matchvars</code>. They need to be present in both <code>recipient</code>
and <code>donor</code>:
For <code>method = "variable_wise"</code> a missing value of a variable
in <code>recipient</code> is imputed by the set of all observed values
of that variable in <code>donor</code>.
For <code>method = "case_wise"</code> the variables only present in
<code>donor</code> are represented as tuples. A missing tuple in
<code>recipient</code> is then imputed by the set of all observed
tuples in <code>donor</code>.
</p>


<h3>Value</h3>

<p>The data.frame resulting in an imprecise imputation
of <code>donor</code> into <code>recipient</code>.
It is also of class <code>"impimp"</code> and stores the imputation
method in its attribute <code>"impmethod"</code>, the names of the
variables of the resulting object containing imputed values
in the attribute <code>"imputedvarnames"</code>, as well as the
list of (guessed) levels of each underlying variable in
<code>"varlevels"</code>.
</p>


<h3>Reserved characters</h3>

<p>The variable names and observations in <code>recipient</code> and
<code>donor</code> must not contain characters that are reserved for
internal purpose.
The actual characters that are internally used are stored in the
options <code>options("impimp.obssep")</code> and
<code>options("impimp.varssep")</code>. The former is used to separate
the values of a set-valued observation, while the other is used
for a concise tupel representation.
</p>


<h3>Note</h3>

<p>This method does not require that all variables in <code>recipient</code>
and <code>donor</code> are <code>factor</code> variables, however,
the imputation methods apply coercion to factor, so purely
numerical variables will be treated as factors eventually.
It does assume (and test for it) that there are no missing
values present in the matching variables.
</p>


<h3>References</h3>

<p>Endres, E., Fink, P. and Augustin, T. (2018),
Imprecise Imputation: A Nonparametric Micro Approach Reflecting
the Natural Uncertainty of Statistical Matching with Categorical
Data, <em>Department of Statistics (LMU Munich): Technical Reports</em>,
No. 214. URL <a href="https://epub.ub.uni-muenchen.de/42423/">https://epub.ub.uni-muenchen.de/42423/</a>.
</p>


<h3>See Also</h3>

<p>for the estimation of probabilities <code>impest</code>
and <code>impestcond</code>; <code>rbindimpimp</code> for
joining two <code>impimp</code> objects
</p>


<h3>Examples</h3>

<pre><code class="language-R">A &lt;- data.frame(x1 = c(1,0), x2 = c(0,0),
                y1 = c(1,0), y2 = c(2,2))
B &lt;- data.frame(x1 = c(1,1,0), x2 = c(0,0,0),
                z1 = c(0,1,1), z2 = c(0,1,2))
impimp(A, B, method = "variable_wise")

## Specifically setting the possible levels of 'z1'
impimp(A, B, method = "domain", vardomains = list(z1 = c(0:5)))

</code></pre>


</div>