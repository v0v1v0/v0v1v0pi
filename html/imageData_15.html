<div class="container">

<table style="width: 100%;"><tr>
<td>imageData-package</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>
Aids in Processing and Plotting Data from a Lemna-Tec Scananalyzer
</h2>

<h3>Description</h3>

<p>Note that 'imageData' has been superseded by 'growthPheno'. 
    The package 'growthPheno' incorporates all the functionality of 
    'imageData' and has functionality not available in 'imageData', 
    but some 'imageData' functions have been renamed.  
    The 'imageData' package is no longer maintained, but is retained 
    for legacy purposes. 
</p>
<p><b>Version:</b> 0.1-62
</p>
<p><b>Date:</b> 2023-08-21
</p>


<h3>Index</h3>

<p>For an overview of the use of these functions and an example see below.
</p>

<table>
<tr>
<td style="text-align: left;">
(i) Data</td>
</tr>
<tr>
<td style="text-align: left;"></td>
</tr>
<tr>
<td style="text-align: left;">

<code>RiceRaw.dat</code> 
  </td>
<td style="text-align: left;"> Data for an experiment to investigate a rice </td>
</tr>
<tr>
<td style="text-align: left;">
       germplasm panel.</td>
</tr>
<tr>
<td style="text-align: left;"></td>
</tr>
<tr>
<td style="text-align: left;">

(ii) Data frame manipulation</td>
</tr>
<tr>
<td style="text-align: left;"></td>
</tr>
<tr>
<td style="text-align: left;">

<code>designFactors</code> 
  </td>
<td style="text-align: left;"> Adds the factors and covariates for a blocked,</td>
</tr>
<tr>
<td style="text-align: left;">
  </td>
<td style="text-align: left;"> split-plot design.</td>
</tr>
<tr>
<td style="text-align: left;">
<code>getDates</code> 
  </td>
<td style="text-align: left;"> Forms a subset of 'responses' in 'data' that</td>
</tr>
<tr>
<td style="text-align: left;">
  </td>
<td style="text-align: left;"> contains their values for the nominated times.</td>
</tr>
<tr>
<td style="text-align: left;">
<code>importExcel</code> 
  </td>
<td style="text-align: left;"> Imports an Excel imaging file and allows some</td>
</tr>
<tr>
<td style="text-align: left;">
  </td>
<td style="text-align: left;"> renaming of variables.</td>
</tr>
<tr>
<td style="text-align: left;">
<code>longitudinalPrime</code> 
  </td>
<td style="text-align: left;"> Selects a set variables to be retained in a</td>
</tr>
<tr>
<td style="text-align: left;">
  </td>
<td style="text-align: left;"> data frame of longitudinal data.</td>
</tr>
<tr>
<td style="text-align: left;">
<code>twoLevelOpcreate</code> 
  </td>
<td style="text-align: left;"> Creates a data.frame formed by applying, for</td>
</tr>
<tr>
<td style="text-align: left;">
  </td>
<td style="text-align: left;"> each response, abinary operation to the values of </td>
</tr>
<tr>
<td style="text-align: left;">
  </td>
<td style="text-align: left;"> two different treatments.</td>
</tr>
<tr>
<td style="text-align: left;">
</td>
</tr>
<tr>
<td style="text-align: left;">
(iii) Plots</td>
</tr>
<tr>
<td style="text-align: left;"></td>
</tr>
<tr>
<td style="text-align: left;">

<code>anomPlot</code> 
  </td>
<td style="text-align: left;"> Identifies anomalous individuals and produces</td>
</tr>
<tr>
<td style="text-align: left;">
  </td>
<td style="text-align: left;"> longitudinal plots without them and with just them.</td>
</tr>
<tr>
<td style="text-align: left;">
<code>corrPlot</code> 
  </td>
<td style="text-align: left;"> Calculates and plots correlation matrices for a</td>
</tr>
<tr>
<td style="text-align: left;">
  </td>
<td style="text-align: left;"> set of responses.</td>
</tr>
<tr>
<td style="text-align: left;">
<code>imagetimesPlot</code> 
  </td>
<td style="text-align: left;"> Plots the time within an interval versus the interval.</td>
</tr>
<tr>
<td style="text-align: left;"> 
  </td>
<td style="text-align: left;"> For example, the hour of the day carts are imaged</td>
</tr>
<tr>
<td style="text-align: left;">
  </td>
<td style="text-align: left;"> against the days after planting (or some other</td>
</tr>
<tr>
<td style="text-align: left;">
  </td>
<td style="text-align: left;"> number of days after an event).</td>
</tr>
<tr>
<td style="text-align: left;">
<code>longiPlot</code> 
  </td>
<td style="text-align: left;"> Plots longitudinal data from a Lemna Tec </td>
</tr>
<tr>
<td style="text-align: left;">
  </td>
<td style="text-align: left;"> Scananalyzer.</td>
</tr>
<tr>
<td style="text-align: left;">
<code>probeDF</code> 
  </td>
<td style="text-align: left;"> Compares, for a set of specified values of df,</td>
</tr>
<tr>
<td style="text-align: left;">
  </td>
<td style="text-align: left;"> a response and the smooths of it, possibly along</td>
</tr>
<tr>
<td style="text-align: left;">
  </td>
<td style="text-align: left;">  with growth rates calculated from the smooths.</td>
</tr>
<tr>
<td style="text-align: left;">
</td>
</tr>
<tr>
<td style="text-align: left;">
(iv) Calculations value-by-value</td>
</tr>
<tr>
<td style="text-align: left;"></td>
</tr>
<tr>
<td style="text-align: left;">

<code>GrowthRates</code> 
  </td>
<td style="text-align: left;"> Calculates growth rates (AGR, PGR, RGRdiff) </td>
</tr>
<tr>
<td style="text-align: left;">
  </td>
<td style="text-align: left;"> between pairs of values in a vector.</td>
</tr>
<tr>
<td style="text-align: left;">
<code>WUI</code> 
  </td>
<td style="text-align: left;"> Calculates the Water Use Index (WUI).</td>
</tr>
<tr>
<td style="text-align: left;">
<code>anom</code> 
  </td>
<td style="text-align: left;"> Tests if any values in a vector are anomalous</td>
</tr>
<tr>
<td style="text-align: left;">
  </td>
<td style="text-align: left;"> in being outside specified limits.</td>
</tr>
<tr>
<td style="text-align: left;">
<code>calcTimes</code> 
  </td>
<td style="text-align: left;"> Calculates for a set of times, the time intervals </td>
</tr>
<tr>
<td style="text-align: left;">
  </td>
<td style="text-align: left;"> after an origin time and the position of each with </td>
</tr>
<tr>
<td style="text-align: left;">
  </td>
<td style="text-align: left;"> in that time.</td>
</tr>
<tr>
<td style="text-align: left;">
<code>calcLagged</code> 
  </td>
<td style="text-align: left;"> Replaces the values in a vector with the result</td>
</tr>
<tr>
<td style="text-align: left;">
  </td>
<td style="text-align: left;"> of applying an operation to it and a lagged value.</td>
</tr>
<tr>
<td style="text-align: left;">
<code>cumulate</code> 
  </td>
<td style="text-align: left;"> Calculates the cumulative sum, ignoring the</td>
</tr>
<tr>
<td style="text-align: left;">
  </td>
<td style="text-align: left;"> first element if exclude.1st is TRUE.</td>
</tr>
<tr>
<td style="text-align: left;">
</td>
</tr>
<tr>
<td style="text-align: left;">
(v) Calculations over multiple values</td>
</tr>
<tr>
<td style="text-align: left;"></td>
</tr>
<tr>
<td style="text-align: left;">

<code>fitSpline</code> 
  </td>
<td style="text-align: left;"> Produce the fits from a natural cubic smoothing</td>
</tr>
<tr>
<td style="text-align: left;">
  </td>
<td style="text-align: left;"> spline applied to a response in a 'data.frame'.</td>
</tr>
<tr>
<td style="text-align: left;">
<code>intervalGRaverage</code> 
  </td>
<td style="text-align: left;"> Calculates the growth rates for a specified</td>
</tr>
<tr>
<td style="text-align: left;">
  </td>
<td style="text-align: left;"> time interval by taking weighted averages of</td>
</tr>
<tr>
<td style="text-align: left;">
  </td>
<td style="text-align: left;"> growth rates for times within the interval.</td>
</tr>
<tr>
<td style="text-align: left;">
<code>intervalGRdiff</code> 
  </td>
<td style="text-align: left;"> Calculates the growth rates for a specified</td>
</tr>
<tr>
<td style="text-align: left;">
  </td>
<td style="text-align: left;"> time interval.</td>
</tr>
<tr>
<td style="text-align: left;">
<code>intervalValueCalculate</code>
  </td>
<td style="text-align: left;"> Calculates a single value that is a function of</td>
</tr>
<tr>
<td style="text-align: left;">
  </td>
<td style="text-align: left;"> an individual's values for a response over a</td>
</tr>
<tr>
<td style="text-align: left;">
  </td>
<td style="text-align: left;"> specified time interval.</td>
</tr>
<tr>
<td style="text-align: left;">
<code>intervalWUI</code> 
  </td>
<td style="text-align: left;"> Calculates water use indices (WUI) over a</td>
</tr>
<tr>
<td style="text-align: left;">
  </td>
<td style="text-align: left;"> specified time interval to a data.frame.</td>
</tr>
<tr>
<td style="text-align: left;">
</td>
</tr>
<tr>
<td style="text-align: left;">
(vi) Caclulations in each split of a 'data.frame' </td>
</tr>
<tr>
<td style="text-align: left;">
</td>
</tr>
<tr>
<td style="text-align: left;">
<code>splitContGRdiff</code> 
  </td>
<td style="text-align: left;"> Adds the growth rates calculated continuously</td>
</tr>
<tr>
<td style="text-align: left;">
  </td>
<td style="text-align: left;"> over time for subsets of a response to a</td>
</tr>
<tr>
<td style="text-align: left;">
  </td>
<td style="text-align: left;"> 'data.frame'.</td>
</tr>
<tr>
<td style="text-align: left;">
<code>splitSplines</code> 
  </td>
<td style="text-align: left;"> Adds the fits after fitting a natural cubic</td>
</tr>
<tr>
<td style="text-align: left;">
  </td>
<td style="text-align: left;"> smoothing spline to subsets of a response to a</td>
</tr>
<tr>
<td style="text-align: left;">
  </td>
<td style="text-align: left;"> 'data.frame'.</td>
</tr>
<tr>
<td style="text-align: left;">
<code>splitValueCalculate</code>   
  </td>
<td style="text-align: left;"> Calculates a single value that is a function of</td>
</tr>
<tr>
<td style="text-align: left;">
  </td>
<td style="text-align: left;"> an individual's values for a response.</td>
</tr>
<tr>
<td style="text-align: left;">
</td>
</tr>
<tr>
<td style="text-align: left;">
(vii) Principal variates analysis (PV A)</td>
</tr>
<tr>
<td style="text-align: left;"></td>
</tr>
<tr>
<td style="text-align: left;">

<code>intervalPVA</code> 
  </td>
<td style="text-align: left;"> Selects a subset of variables observed within a</td>
</tr>
<tr>
<td style="text-align: left;">
  </td>
<td style="text-align: left;"> specified time interval using PVA.</td>
</tr>
<tr>
<td style="text-align: left;">
<code>PVA</code> 
  </td>
<td style="text-align: left;"> Selects a subset of variables using PVA.</td>
</tr>
<tr>
<td style="text-align: left;">
<code>rcontrib</code> 
  </td>
<td style="text-align: left;"> Computes a measure of how correlated each</td>
</tr>
<tr>
<td style="text-align: left;">
  </td>
<td style="text-align: left;"> variable in a set is with the other variable,</td>
</tr>
<tr>
<td style="text-align: left;">
  </td>
<td style="text-align: left;"> conditional on a nominated subset of them.</td>
</tr>
<tr>
<td style="text-align: left;">
</td>
</tr>
</table>
<h3>Overview</h3>

<p>This package can be used to carry out a full seven-step process to produce phenotypic traits from measurements made in a high-throughput phenotyping facility, such as one based on a Lemna-Tec Scananalyzer 3D system and described by Al-Tamimi et al. (2016). Otherwise, individual functions can be used to carry out parts of the process.
</p>
<p>The basic data consists of imaging data obtained from a set of pots or carts over time. The carts are arranged in a grid of Lanes <code class="reqn">\times</code> Positions. There should be a unique identifier for each cart, which by default is <code>Snapshot.ID.Tag</code>, and variable giving the Days after Planting for each measurement, by default <code>Time.after.Planting..d.</code>. In some cases, it is expected that  there will be a column labelled <code>Snapshot.Time.Stamp</code>, which reflects the time of the imaging from which a particular data value was obtained.
</p>
<p>The full seven-step process is as follows:
</p>

<ol>
<li>
<p> Use <code>importExcel</code> to import the raw data from the Excel file. This step should also involve any editing of the data needed to take account of mishaps during the data collection and the need to remove faulty data (produces <code>raw.dat</code>). Generally, data can be removed by replacing only values for responses with  missing values (<code>NA</code>) for carts whose data is to be removed, leaving the identifying information intact.
</p>
</li>
<li>
<p> Use <code>longitudinalPrime</code> to select a subset of the imaging variables produced by the Lemna Tec Scanalyzer and, if the design is a blocked, split-plot design, use <code>designFactors</code> to add covariates and factors that might be used in the analysis (produces the data frame <code>longi.prime.dat</code>).
</p>
</li>
<li>
<p> Add derived traits that result in a value for each observation: use <code>splitContGRdiff</code> to obtain continuous growth rates i.e. a growth rate for each time of observation, except the first; <code>WUI</code> to produce continuous Water Use Efficiency Indices (WUE) and <code>cumulate</code> to produce cumulative responses. (Produces the data frame <code>longi.dat</code>.)
</p>
</li>
<li>
<p> Use <code>splitSplines</code> to fit splines to smooth the longitudinal trends in the primary traits and calculate continuous growth rates from the smoothed response (added to the data frame <code>longi.dat</code>). There are two options for calculating continuous smoothed growth rates: (i) by differencing — use  <code>splitContGRdiff</code>; (ii) from the first derivatives of the splines — in <code>splitSplines</code> include <code>1</code> in the <code>deriv</code> argument, include <code>"AGR"</code> in <code>suffices.deriv</code> and set the <code>RGR</code> to say <code>"RGR"</code>. Optionally, use <code>probeDF</code> to compare the smooths for a number of values of <code>df</code> and, if necessary, re-run <code>splitSplines</code> with a revised value of <code>df</code>.
</p>
</li>
<li>
<p> Perform an exploratory examination of the unsmoothed data by using <code>longiPlot</code> to produce longitudinal plots of unsmoothed imaging traits and continuous growth rates. Also, use <code>longiPlot</code> to plot the smoothed imaging traits and continuous growth rates and <code>anomPlot</code> to check for anomalies in the data.
</p>
</li>
<li>
<p> Produce cart data: traits for which there is a single value for each <code>Snapshot.ID.Tag</code> or cart. (produces the data frame <code>cart.dat</code>)
</p>

<ol>
<li>
<p> Set up a cart data.frame with the factors and covariates for a single observation from all carts. This can be done by subsetting <code>longi.dat</code> so that there is one entry for each cart.
</p>
</li>
<li>
<p> Use <code>getDates</code> to add traits at specific times to the cart <code>data.frame</code>, often the first and last day of imaging for each <code>Snapshot.ID.Tag</code>. The times need to be selected so that there is one and only one observation for each cart. Also form traits, such as growth rates over the whole imaging period, based on these values
</p>
</li>
<li>
<p> Based on the longitudinal plots, decide on the intervals for  which growth rates and WUEs are to be calculated. The growth rates for intervals are calculated from the continuous growth rates, using <code>intervalGRdiff</code>, if the continuous growth rates were calculated by differencing, or <code>intervalGRaverage</code>, if they were calculated from first derivatives. To calculate WUEs for intervals, use <code>intervalWUI</code>, The interval growth rates and WUEs are added to the cart <code>data.frame</code>.
</p>
</li>
</ol>
</li>
<li>
<p> (Optional) There is also the possibility that, for experiments investigating salinity, the Shoot Ion Independent Tolerance (SIIT) index can be calculated using <code>twoLevelOpcreate</code>. 
</p>
</li>
</ol>
<h3>Author(s)</h3>

<p>NA
</p>
<p>Maintainer: NA
</p>


<h3>References</h3>

<p>Al-Tamimi, N, Brien, C.J., Oakey, H., Berger, B., Saade, S., Ho, Y. S., Schmockel, S. M., Tester, M. and Negrao, S. (2016) New salinity tolerance loci revealed in rice using high-throughput non-invasive phenotyping. <em>Nature Communications</em>, <b>7</b>, 13342.
</p>


<h3>See Also</h3>

<p><code>dae</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">## Not run: 
### This example can be run because the data.frame RiceRaw.dat is available with the package
#'# Step 1: Import the raw data
data(RiceRaw.dat)

#'# Step 2: Select imaging variables and add covariates and factors (produces longi.dat)
longi.dat &lt;- longitudinalPrime(data=RiceRaw.dat, smarthouse.lev=c("NE","NW"))

longi.dat &lt;- designFactors(longi.dat, insertName = "xDays",
                           designfactorMethod="StandardOrder")

#'## Particular edits to longi.dat
longi.dat &lt;- within(longi.dat, 
                    { 
                      Days.after.Salting &lt;- as.numfac(Days) - 29
                    })
longi.dat &lt;- with(longi.dat, longi.dat[order(Snapshot.ID.Tag,Days), ])

#'# Step 3: Form derived traits that result in a value for each observation
#'### Set responses
responses.image &lt;- c("Area")
responses.smooth &lt;- paste(responses.image, "smooth", sep=".")

#'## Form growth rates for each observation of a subset of responses by differencing
longi.dat &lt;- splitContGRdiff(longi.dat, responses.image, 
                             INDICES="Snapshot.ID.Tag",
                             which.rates = c("AGR","RGR"))

#'## Form Area.WUE 
longi.dat &lt;- within(longi.dat, 
                    { 
                      Area.WUE &lt;- WUI(Area.AGR*Days.diffs, Water.Loss)
                    })

#'## Add cumulative responses 
longi.dat &lt;- within(longi.dat, 
                    { 
                      Water.Loss.Cum &lt;- unlist(by(Water.Loss, Snapshot.ID.Tag, 
                                                  cumulate, exclude.1st=TRUE))
                      WUE.cum &lt;- Area / Water.Loss.Cum 
                    })

#'# Step 4: Fit splines to smooth the longitudinal trends in the primary traits and
#'# calculate their growth rates
#'
#'## Smooth responses
#+
for (response in c(responses.image, "Water.Loss"))
  longi.dat &lt;- splitSplines(longi.dat, response, x="xDays", INDICES = "Snapshot.ID.Tag", 
                            df = 4, na.rm=TRUE)
longi.dat &lt;- with(longi.dat, longi.dat[order(Snapshot.ID.Tag, xDays), ])

#'## Loop over smoothed responses, forming growth rates by differences
#+
responses.GR &lt;- paste(responses.smooth, "AGR", sep=".")
longi.dat &lt;- splitContGRdiff(longi.dat, responses.smooth, 
                             INDICES="Snapshot.ID.Tag",
                             which.rates = c("AGR","RGR"))

#'## Finalize longi.dat
longi.dat &lt;- with(longi.dat, longi.dat[order(Snapshot.ID.Tag, xDays), ])

#'# Step 5: Do exploratory plots on unsmoothed and smoothed longitudinal data
responses.longi &lt;- c("Area","Area.AGR","Area.RGR", "Area.WUE")
responses.smooth.plot &lt;- c("Area.smooth","Area.smooth.AGR","Area.smooth.RGR")
titles &lt;- c("Total area (1000 pixels)", 
            "Total area AGR (1000 pixels per day)", "Total area RGR (per day)",
            "Total area WUE (1000 pixels per mL)")
titles.smooth&lt;-titles
nresp &lt;- length(responses.longi)
limits &lt;- list(c(0,1000), c(-50,125), c(-0.05,0.40), c(0,30))

#' ### Plot unsmoothed profiles for all longitudinal  responses 
#+ "01-ProfilesAll"
klimit &lt;- 0
for (k in 1:nresp)
{ 
  klimit &lt;- klimit + 1
  longiPlot(data = longi.dat, response = responses.longi[k], 
            y.title = titles[k], x="xDays+35.42857143", 
            ggplotFuncs = list(geom_vline(xintercept=29, linetype="longdash", size=1), 
                               scale_x_continuous(breaks=seq(28, 42, by=2)),
                               scale_y_continuous(limits=limits[[klimit]])))
}


#' ### Plot smoothed profiles for all longitudinal responses - GRs by difference
#+ "01-SmoothedProfilesAll"
nresp.smooth &lt;- length(responses.smooth.plot)
limits &lt;- list(c(0,1000), c(0,100), c(0.0,0.40))
for (k in 1:nresp.smooth)
{ 
  longiPlot(data = longi.dat, response = responses.smooth.plot[k], 
            y.title = titles.smooth[k], x="xDays+35.42857143", 
            ggplotFuncs = list(geom_vline(xintercept=29, linetype="longdash", size=1), 
                               scale_x_continuous(breaks=seq(28, 42, by=2)),
                               scale_y_continuous(limits=limits[[klimit]])))
  print(plt)
}


#'### AGR anomalies - plot without anomalous plants followed by plot of anomalous plants
#+ "01-0254-AGRanomalies"
anom.ID &lt;- vector(mode = "character", length = 0L)
response &lt;- "Area.smooth.AGR"
cols.output &lt;- c("Snapshot.ID.Tag", "Smarthouse", "Lane", "Position", 
                 "Treatment.1", "Genotype.ID", "Days")
anomalous &lt;- anomPlot(longi.dat, response=response, lower=2.5, start.time=40, 
                      x = "xDays+35.42857143", vertical.line=29, breaks=seq(28, 42, by=2), 
                      whichPrint=c("innerPlot"), y.title=response)
subs &lt;- subset(anomalous$data, Area.smooth.AGR.anom &amp; Days==42)
if (nrow(subs) == 0)
{ cat("\n#### No anomalous data here\n\n")
} else
{ 
  subs &lt;- subs[order(subs["Smarthouse"],subs["Treatment.1"], subs[response]),]
  print(subs[c(cols.output, response)])
  anom.ID &lt;- unique(c(anom.ID, subs$Snapshot.ID.Tag))
  outerPlot &lt;- anomalous$outerPlot  + geom_text(data=subs,
                                                aes_string(x = "xDays+35.42857143", 
                                                           y = response, 
                                                           label="Snapshot.ID.Tag"), 
                                                size=3, hjust=0.7, vjust=0.5)
  print(outerPlot)
}


#'# Step 6: Form single-value plant responses in Snapshot.ID.Tag order.
#'
#'## 6a) Set up a data frame with factors only
#+
cart.dat &lt;- longi.dat[longi.dat$Days == 31, 
                      c("Smarthouse","Lane","Position","Snapshot.ID.Tag",
                        "xPosn","xMainPosn",
                        "Zones","xZones","SHZones","ZLane","ZMainplots", "Subplots",
                        "Genotype.ID","Treatment.1")]
cart.dat &lt;- cart.dat[do.call(order, cart.dat), ]

#'## 6b) Get responses based on first and last date.
#'
#'### Observation for first and last date
cart.dat &lt;- cbind(cart.dat, getDates(responses.image, data = longi.dat, 
                                     which.times = c(31), suffix = "first"))
cart.dat &lt;- cbind(cart.dat, getDates(responses.image, data = longi.dat, 
                                     which.times = c(42), suffix = "last"))
cart.dat &lt;- cbind(cart.dat, getDates(c("WUE.cum"), 
                                     data = longi.dat, 
                                     which.times = c(42), suffix = "last"))
responses.smooth &lt;- paste(responses.image, "smooth", sep=".")
cart.dat &lt;- cbind(cart.dat, getDates(responses.smooth, data = longi.dat, 
                                     which.times = c(31), suffix = "first"))
cart.dat &lt;- cbind(cart.dat, getDates(responses.smooth, data = longi.dat, 
                                     which.times = c(42), suffix = "last"))

#'### Growth rates over whole period.
#+
tottime &lt;- 42 - 31
cart.dat &lt;- within(cart.dat, 
                   { 
                     Area.AGR &lt;- (Area.last - Area.first)/tottime
                     Area.RGR &lt;- log(Area.last / Area.first)/tottime
                   })

#'### Calculate water index over whole period
cart.dat &lt;- merge(cart.dat, 
                  intervalWUI("Area", water.use = "Water.Loss", 
                              start.times = c(31), 
                              end.times = c(42), 
                              suffix = NULL, 
                              data = longi.dat, include.total.water = TRUE),
                  by = c("Snapshot.ID.Tag"))
names(cart.dat)[match(c("Area.WUI","Water.Loss.Total"),names(cart.dat))] &lt;- 
        c("Area.Overall.WUE", "Water.Loss.Overall")
cart.dat$Water.Loss.rate.Overall &lt;- cart.dat$Water.Loss.Overall / (42 - 31)

#'## 6c) Add growth rates and water indices for intervals
#'### Set up intervals
#+
start.days &lt;- list(31,35,31,38)
end.days &lt;- list(35,38,38,42)
suffices &lt;- list("31to35","35to38","31to38","38to42")

#'### Rates for specific intervals from the smoothed data by differencing
#+
for (r in responses.smooth)
{ for (k in 1:length(suffices))
  { 
    cart.dat &lt;- merge(cart.dat, 
                      intervalGRdiff(r, 
                                     which.rates = c("AGR","RGR"), 
                                     start.times = start.days[k][[1]], 
                                     end.times = end.days[k][[1]], 
                                     suffix.interval = suffices[k][[1]], 
                                     data = longi.dat),
                      by = "Snapshot.ID.Tag")
  }
}

#'### Water indices for specific intervals from the unsmoothed and smoothed data
#+
for (k in 1:length(suffices))
{ 
  cart.dat &lt;- merge(cart.dat, 
                    intervalWUI("Area", water.use = "Water.Loss", 
                                start.times = start.days[k][[1]], 
                                end.times = end.days[k][[1]], 
                                suffix = suffices[k][[1]], 
                                data = longi.dat, include.total.water = TRUE),
                    by = "Snapshot.ID.Tag")
  names(cart.dat)[match(paste("Area.WUI", suffices[k][[1]], sep="."), 
                        names(cart.dat))] &lt;- paste("Area.WUE", suffices[k][[1]], sep=".")
  cart.dat[paste("Water.Loss.rate", suffices[k][[1]], sep=".")] &lt;- 
           cart.dat[[paste("Water.Loss.Total", suffices[k][[1]], sep=".")]] / 
                                           ( end.days[k][[1]] - start.days[k][[1]])
}

cart.dat &lt;- with(cart.dat, cart.dat[order(Snapshot.ID.Tag), ])

#'# Step 7: Form continuous and interval SIITs
#'
#'## 7a) Calculate continuous
#+
cols.retained &lt;-  c("Snapshot.ID.Tag","Smarthouse","Lane","Position",
                    "Days","Snapshot.Time.Stamp", "Hour", "xDays",
                    "Zones","xZones","SHZones","ZLane","ZMainplots",
                    "xMainPosn", "Genotype.ID")
responses.GR &lt;- c("Area.smooth.AGR","Area.smooth.AGR","Area.smooth.RGR")
suffices.results &lt;- c("diff", "SIIT", "SIIT")
responses.SIIT &lt;- unlist(Map(paste, responses.GR, suffices.results,sep="."))

longi.SIIT.dat &lt;- 
  twoLevelOpcreate(responses.GR, longi.dat, suffices.treatment=c("C","S"),
                   operations = c("-", "/", "/"), suffices.results = suffices.results, 
                   columns.retained = cols.retained, 
                   by = c("Smarthouse","Zones","ZMainplots","Days"))
longi.SIIT.dat &lt;- with(longi.SIIT.dat, 
                            longi.SIIT.dat[order(Smarthouse,Zones,ZMainplots,Days),])

#' ### Plot SIIT profiles 
#' 
#+ "03-SIITProfiles"
k &lt;- 2
nresp &lt;- length(responses.SIIT)
limits &lt;- with(longi.SIIT.dat, list(c(min(Area.smooth.AGR.diff, na.rm=TRUE),
                                      max(Area.smooth.AGR.diff, na.rm=TRUE)),
                                    c(0,3),
                                    c(0,1.5)))
#Plots
for (k in 1:nresp)
{ 
  longiPlot(data = longi.SIIT.dat, x="xDays+35.42857143", 
            response = responses.SIIT[k], 
            y.title=responses.SIIT[k], 
            facet.x="Smarthouse", facet.y=".", 
            ggplotFuncs = list(geom_vline(xintercept=29, linetype="longdash", size=1), 
                               scale_x_continuous(breaks=seq(28, 42, by=2)),
                               scale_y_continuous(limits=limits[[klimit]])))
}

#'## 7b) Calculate interval SIITs and check for large values for SIIT for Days 31to35
#+ "01-SIITIntClean"
suffices &lt;- list("31to35","35to38","31to38","38to42")
response &lt;- "Area.smooth.RGR.31to35"
SIIT &lt;- paste(response, "SIIT", sep=".")
responses.SIITinterval &lt;- as.vector(outer("Area.smooth.RGR", suffices, paste, sep="."))

cart.SIIT.dat &lt;- twoLevelOpcreate(responses.SIITinterval, cart.dat, 
                                  suffices.treatment=c("C","S"), 
                                  suffices.results="SIIT", 
                                  columns.suffixed="Snapshot.ID.Tag")
tmp&lt;-na.omit(cart.SIIT.dat)
print(summary(tmp[SIIT]))
big.SIIT &lt;- with(tmp, tmp[tmp[SIIT] &gt; 1.15, c("Snapshot.ID.Tag.C","Genotype.ID",
                                              paste(response,"C",sep="."), 
                                              paste(response,"S",sep="."), SIIT)])
big.SIIT &lt;- big.SIIT[order(big.SIIT[SIIT]),]
print(big.SIIT)
plt &lt;- ggplot(tmp, aes_string(SIIT)) +
           geom_histogram(aes(y = ..density..), binwidth=0.05) +
           geom_vline(xintercept=1.15, linetype="longdash", size=1) +
           theme_bw() + facet_grid(Smarthouse ~.)
print(plt)
plt &lt;- ggplot(tmp, aes_string(x="Smarthouse", y=SIIT)) +
           geom_boxplot() + theme_bw()
print(plt)
remove(tmp)

## End(Not run)</code></pre>


</div>