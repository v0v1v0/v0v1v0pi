<div class="container">

<table style="width: 100%;"><tr>
<td>plot.Results_IMIFA</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Plotting output and parameters of inferential interest for IMIFA and related models</h2>

<h3>Description</h3>

<p>Plotting output and parameters of inferential interest for IMIFA and related models
</p>


<h3>Usage</h3>

<pre><code class="language-R">## S3 method for class 'Results_IMIFA'
plot(x,
     plot.meth = c("all", "correlation", "density", "errors", "GQ",
                   "means", "parallel.coords", "trace", "zlabels"),
     param = c("means", "scores", "loadings", "uniquenesses",
               "pis", "alpha", "discount"),
     g = NULL,
     mat = TRUE,
     zlabels = NULL,
     heat.map = TRUE,
     show.last = FALSE,
     palette = NULL,
     ind = NULL,
     fac = NULL,
     by.fac = FALSE,
     type = c("h", "n", "p", "l"),
     intervals = TRUE,
     common = TRUE,
     partial = FALSE,
     titles = TRUE,
     transparency = 0.75,
     ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>An object of class <code>"Results_IMIFA"</code> generated by <code>get_IMIFA_results</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>plot.meth</code></td>
<td>
<p>The type of plot to be produced for the <code>param</code> of interest, where <code>correlation</code> refers to ACF/PACF plots, <code>means</code> refers to posterior means, <code>density</code>, <code>trace</code> and <code>parallel.coords</code> are self-explanatory. <code>"all"</code> in this case, the default, refers to <code>"trace"</code>, <code>"density"</code>, <code>"means"</code>, and <code>"correlation"</code>. <code>"parallel.coords"</code> is only available when <code>param</code> is one of <code>"means"</code>, <code>"loadings"</code>, or <code>"uniquenesses"</code> - note that this method applies a small amount of horizontal jitter to avoid overplotting.
</p>
<p>Special types of plots which don't require a <code>param</code> are:
</p>

<dl>
<dt><code>"GQ"</code></dt>
<dd>
<p>for plotting the posterior summaries of the numbers of clusters/factors, if available.</p>
</dd>
<dt><code>"zlabels"</code></dt>
<dd>
<p>for plotting clustering uncertainties - in four different ways (incl. the posterior confusion matrix) - if clustering has taken place, with or without the clustering labels being supplied via the <code>zlabels</code> argument. If available, the average similarity matrix, reordered according to the MAP labels, is shown as a 5-th plot.</p>
</dd>
<dt><code>"errors"</code></dt>
<dd>
<p>for conducting posterior predictive checking of the appropriateness of the fitted model by visualising the posterior predictive reconstruction error (PPRE) &amp;/or histograms comparing the data to replicate draws from the posterior distribution &amp;/or error metrics quantifying the difference between the estimated and empirical covariance matrices. The type of plot(s) produced depends on how the <code>error.metrics</code> argument was supplied to <code>get_IMIFA_results</code> and what parameters were stored.</p>
</dd>
</dl>
<p>The argument <code>g</code> can be used to cycle through the available plots in each case. <code>ind</code> can also be used to govern which variable is shown for the 2-nd plot.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>param</code></td>
<td>
<p>The parameter of interest for any of the following <code>plot.meth</code> options: <code>all</code>, <code>trace</code>, <code>density</code>, <code>means</code>, <code>correlation</code>. The <code>param</code> must have been stored when <code>mcmc_IMIFA</code> was initially ran. Includes <code>pis</code> for methods where clustering takes place, and allows posterior inference on <code>alpha</code> (for the <code>"IMFA"</code>, <code>"IMIFA"</code>, <code>"OMFA"</code>, and <code>"OMIFA"</code> methods) and <code>discount</code> (for the <code>"IMFA"</code> and <code>"IMIFA"</code> methods). Otherwise <code>"means"</code>, <code>"scores"</code>, <code>"loadings"</code>, and <code>"uniquenesses"</code> can be plotted.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>g</code></td>
<td>
<p>Optional argument that allows specification of exactly which cluster the plot of interest is to be produced for. If not supplied, the user will be prompted to cycle through plots for all clusters. Also functions as an index for which plot to return when <code>plot.meth</code> is <code>GQ</code>, <code>zlabels</code>, or <code>errors</code> in much the same way.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>mat</code></td>
<td>
<p>Logical indicating whether a <code>matplot</code> is produced (defaults to <code>TRUE</code>). If given as <code>FALSE</code>, <code>ind</code> is invoked.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>zlabels</code></td>
<td>
<p>The true labels can be supplied if they are known. If this is not supplied, the function uses the labels that were supplied, if any, to <code>get_IMIFA_results</code>. Only relevant when <code>plot.meth = "zlabels"</code>. When explicitly supplied, misclassified observations are highlighted in the first type of uncertainty plot (otherwise observations whose uncertainty exceed the inverse of the number of clusters are highlighted). For the second type of uncertainty plot, when <code>zlabels</code> are explicitly supplied, the uncertainty of misclassified observations is marked by vertical lines on the profile plot.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>heat.map</code></td>
<td>
<p>A logical which controls plotting posterior mean loadings or posterior mean scores as a heatmap, or else as something akin to <code>link{plot(..., type="h")}</code>. Only relevant if <code>param = "loadings"</code> (in which case the default is <code>TRUE</code>) or <code>param = "scores"</code> (in which case the default is <code>FALSE</code>). Heatmaps are produced with the aid of <code>mat2cols</code> and <code>plot_cols</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>show.last</code></td>
<td>
<p>A logical indicator which defaults to <code>FALSE</code>, but when <code>TRUE</code> replaces any instance of the posterior mean with the last valid sample. Only relevant when <code>param</code> is one of <code>"means"</code> <code>"scores"</code>, <code>"loadings"</code>, <code>"uniquenesses"</code>, or <code>"pis"</code> and <code>plot.meth</code> is one of <code>"all"</code> or <code>"means"</code>. Also relevant for <code>"means"</code>, <code>"loadings"</code> and <code>"uniquenesses"</code> when <code>plot.meth</code> is <code>"parallel.coords"</code>. When <code>TRUE</code>, this has the effect of forcing <code>intervals</code> to be <code>FALSE</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>palette</code></td>
<td>
<p>An optional colour palette to be supplied if overwriting the default palette set inside the function by <code>viridis</code> is desired. It makes little sense to a supply a <code>palette</code> when <code>plot.meth="all"</code> and <code>param</code> is one of <code>"scores"</code> or <code>"loadings"</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ind</code></td>
<td>
<p>Either a single number indicating which variable to plot when <code>param</code> is one of <code>means</code> or <code>uniquenesses</code> (or <code>plot.meth="errors"</code>), or which cluster to plot if <code>param</code> is <code>pis</code>. If <code>scores</code> are plotted, a vector of length two giving which observation and factor to plot; if <code>loadings</code> are plotted, a vector of length two giving which variable and factor to plot. Will be recycled to length 2 if necessary. Also governs which two factors are displayed on posterior mean plots of the <code>"scores"</code> when <code>heat.map</code> is <code>FALSE</code>; otherwise only relevant when <code>mat</code> is <code>FALSE</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>fac</code></td>
<td>
<p>Optional argument that provides an alternative way to specify <code>ind[2]</code> when <code>mat</code> is <code>FALSE</code> and <code>param</code> is one of <code>scores</code> or <code>loadings</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>by.fac</code></td>
<td>
<p>Optionally allows (mat)plotting of scores and loadings by factor - i.e. observation(s) (scores) or variable(s) (loadings) for a given factor, respectively, controlled by <code>ind</code> or <code>fac</code>) when set to <code>TRUE</code>. Otherwise all factor(s) are plotted for a given observation or variable when set to <code>FALSE</code> (the default), again controlled by <code>ind</code> or <code>fac</code>. Only relevant when <code>param</code> is one of <code>scores</code> or <code>loadings</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>type</code></td>
<td>
<p>The manner in which the plot is to be drawn, as per the <code>type</code> argument to <code>plot</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>intervals</code></td>
<td>
<p>Logical indicating whether credible intervals around the posterior mean(s) are to be plotted when <code>is.element(plot.meth, c("all", "means"))</code>. Defaults to <code>TRUE</code>, but can only be <code>TRUE</code> when <code>show.last</code> is <code>FALSE</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>common</code></td>
<td>
<p>Logical indicating whether plots with <code>plot.meth="means"</code> (or the corresponding plots for <code>plot.meth="all"</code>) when <code>param</code> is one of <code>"means"</code>, <code>"scores"</code>, <code>"loadings"</code>, or <code>"uniquenesses"</code> are calibrated to a common scale based on the range of the <code>param</code> parameters across all clusters (defaults to <code>TRUE</code>, and only relevant when there are clusters). Otherwise, the only the range corresponding to the image being plotted is used to determine the scale.
</p>
<p>Note that this affects the <code>"loadings"</code> and <code>"scores"</code> plots regardless of the value of <code>heat.map</code>. An exception is the <code>"scores"</code> plots when <code>plot.meth="means"</code> and <code>heat.map</code> is <code>FALSE</code>, in which case <code>common</code> defaults to <code>FALSE</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>partial</code></td>
<td>
<p>Logical indicating whether plots of type <code>"correlation"</code> use the PACF. The default, <code>FALSE</code>, ensures the ACF is used. Only relevant when <code>plot.meth = "all"</code>, otherwise both plots are produced when <code>plot.meth = "correlation"</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>titles</code></td>
<td>
<p>Logical indicating whether default plot titles are to be used (<code>TRUE</code>), or suppressed (<code>FALSE</code>).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>transparency</code></td>
<td>
<p>A factor in [0, 1] modifying the opacity for overplotted lines. Defaults to 0.75, unless semi-transparency is not supported. Only relevant when <code>palette</code> is not supplied, otherwise the supplied <code>palette</code> must already be adjusted for transparency.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>Other arguments typically passed to <code>plot</code> or the <code>breaks</code> argument to <code>mat2cols</code> and <code>heat_legend</code> when heatmaps are plotted.</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p>The desired plot with appropriate output and summary statistics printed to the console screen.
</p>


<h3>Note</h3>

<p>Supplying the argument <code>zlabels</code> does <strong>not</strong> have the same effect of reordering the sampled parameters as it does if supplied directly to <code>get_IMIFA_results</code>.
</p>
<p>When <code>mat</code> is <code>TRUE</code> and <code>by.fac</code> is <code>FALSE</code> (both defaults), the convention for dealing with overplotting for <code>trace</code> and <code>density</code> plots when <code>param</code> is either <code>scores</code> or <code>loadings</code> is to plot the last factor first, such that the first factor appears 'on top'.
</p>


<h3>Author(s)</h3>

<p>Keefe Murphy - &lt;<a href="mailto:keefe.murphy@mu.ie">keefe.murphy@mu.ie</a>&gt;
</p>


<h3>References</h3>

<p>Murphy, K., Viroli, C., and Gormley, I. C. (2020) Infinite mixtures of infinite factor analysers, <em>Bayesian Analysis</em>, 15(3): 937-963. &lt;<a href="https://doi.org/10.1214/19-BA1179">doi:10.1214/19-BA1179</a>&gt;.
</p>


<h3>See Also</h3>

<p><code>mcmc_IMIFA</code>, <code>get_IMIFA_results</code>, <code>mat2cols</code>, <code>plot_cols</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R"># See the vignette associated with the package for more graphical examples:
# vignette("IMIFA", package = "IMIFA")

# data(olive)
# simIMIFA &lt;- mcmc_IMIFA(olive, method="IMIFA")
# resIMIFA &lt;- get_IMIFA_results(simIMIFA, z.avgsim=TRUE)

# Examine the posterior distribution(s) of the number(s) of clusters (G) &amp;/or latent factors (Q)
# For the IM(I)FA and OM(I)FA methods, this also plots the trace of the active/non-empty clusters
# plot(resIMIFA, plot.meth="GQ")
# plot(resIMIFA, plot.meth="GQ", g=2)

# Plot clustering uncertainty (and, if available, the similarity matrix)
# plot(resIMIFA, plot.meth="zlabels", zlabels=olive$area)

# Visualise the posterior predictive reconstruction error
# plot(resIMIFA, plot.meth="errors", g=1)

# Compare histograms of the data vs. replicate draw from the posterior for the 1st variable
# plot(resIMIFA, plot.meth="errors", g=2, ind=1)

# Visualise empirical vs. estimated covariance error metrics
# plot(resIMIFA, plot.meth="errors", g=3)

# Look at the trace, density, posterior mean, and correlation of various parameters of interest
# plot(resIMIFA, plot.meth="all", param="means", g=1)
# plot(resIMIFA, plot.meth="all", param="means", g=1, ind=2)
# plot(resIMIFA, plot.meth="trace", param="scores")
# plot(resIMIFA, plot.meth="trace", param="scores", by.fac=TRUE)
# plot(resIMIFA, plot.meth="mean", param="loadings", g=1)
# plot(resIMIFA, plot.meth="mean", param="loadings", g=1, heat.map=FALSE)
# plot(resIMIFA, plot.meth="parallel.coords", param="uniquenesses")
# plot(resIMIFA, plot.meth="density", param="pis", intervals=FALSE, partial=TRUE)
# plot(resIMIFA, plot.meth="all", param="alpha")
# plot(resIMIFA, plot.meth="all", param="discount")
</code></pre>


</div>