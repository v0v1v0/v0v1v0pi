<div class="container">

<table style="width: 100%;"><tr>
<td>weightedmean</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Calculate the weighted mean age</h2>

<h3>Description</h3>

<p>Averages heteroscedastic data either using the ordinary weighted
mean, or using a random effects model with two sources of variance.
Computes the MSWD of a normal fit without
overdispersion. Implements a modified Chauvenet criterion to detect
and reject outliers. Only propagates the systematic uncertainty
associated with decay constants and calibration factors after
computing the weighted mean isotopic composition. Does not propagate
the uncertainty of any initial daughter correction, because this is
neither a purely random or purely systematic uncertainty.
</p>


<h3>Usage</h3>

<pre><code class="language-R">weightedmean(x, ...)

## Default S3 method:
weightedmean(
  x,
  from = NA,
  to = NA,
  random.effects = FALSE,
  detect.outliers = TRUE,
  plot = TRUE,
  levels = NA,
  clabel = "",
  rect.col = c("#00FF0080", "#FF000080"),
  outlier.col = "#00FFFF80",
  sigdig = 2,
  oerr = 3,
  ranked = FALSE,
  hide = NULL,
  omit = NULL,
  omit.col = NA,
  ...
)

## S3 method for class 'other'
weightedmean(
  x,
  from = NA,
  to = NA,
  random.effects = FALSE,
  detect.outliers = TRUE,
  plot = TRUE,
  levels = NA,
  clabel = "",
  rect.col = c("#00FF0080", "#FF000080"),
  outlier.col = "#00FFFF80",
  sigdig = 2,
  oerr = 3,
  ranked = FALSE,
  hide = NULL,
  omit = NULL,
  omit.col = NA,
  ...
)

## S3 method for class 'UPb'
weightedmean(
  x,
  random.effects = FALSE,
  detect.outliers = TRUE,
  plot = TRUE,
  from = NA,
  to = NA,
  levels = NA,
  clabel = "",
  rect.col = c("#00FF0080", "#FF000080"),
  outlier.col = "#00FFFF80",
  sigdig = 2,
  type = 4,
  cutoff.76 = 1100,
  oerr = 3,
  cutoff.disc = discfilter(),
  exterr = FALSE,
  ranked = FALSE,
  common.Pb = 0,
  hide = NULL,
  omit = NULL,
  omit.col = NA,
  ...
)

## S3 method for class 'PbPb'
weightedmean(
  x,
  random.effects = FALSE,
  detect.outliers = TRUE,
  plot = TRUE,
  from = NA,
  to = NA,
  levels = NA,
  clabel = "",
  rect.col = c("#00FF0080", "#FF000080"),
  outlier.col = "#00FFFF80",
  sigdig = 2,
  oerr = 3,
  exterr = FALSE,
  common.Pb = 2,
  ranked = FALSE,
  hide = NULL,
  omit = NULL,
  omit.col = NA,
  ...
)

## S3 method for class 'ThU'
weightedmean(
  x,
  random.effects = FALSE,
  detect.outliers = TRUE,
  plot = TRUE,
  from = NA,
  to = NA,
  levels = NA,
  clabel = "",
  rect.col = c("#00FF0080", "#FF000080"),
  outlier.col = "#00FFFF80",
  sigdig = 2,
  oerr = 3,
  ranked = FALSE,
  Th0i = 0,
  hide = NULL,
  omit = NULL,
  omit.col = NA,
  ...
)

## S3 method for class 'ArAr'
weightedmean(
  x,
  random.effects = FALSE,
  detect.outliers = TRUE,
  plot = TRUE,
  from = NA,
  to = NA,
  levels = NA,
  clabel = "",
  rect.col = c("#00FF0080", "#FF000080"),
  outlier.col = "#00FFFF80",
  sigdig = 2,
  oerr = 3,
  exterr = FALSE,
  ranked = FALSE,
  i2i = FALSE,
  hide = NULL,
  omit = NULL,
  omit.col = NA,
  ...
)

## S3 method for class 'KCa'
weightedmean(
  x,
  random.effects = FALSE,
  detect.outliers = TRUE,
  plot = TRUE,
  from = NA,
  to = NA,
  levels = NA,
  clabel = "",
  rect.col = c("#00FF0080", "#FF000080"),
  outlier.col = "#00FFFF80",
  sigdig = 2,
  oerr = 3,
  exterr = FALSE,
  ranked = FALSE,
  i2i = FALSE,
  hide = NULL,
  omit = NULL,
  omit.col = NA,
  ...
)

## S3 method for class 'ThPb'
weightedmean(
  x,
  random.effects = FALSE,
  detect.outliers = TRUE,
  plot = TRUE,
  from = NA,
  to = NA,
  levels = NA,
  clabel = "",
  rect.col = c("#00FF0080", "#FF000080"),
  outlier.col = "#00FFFF80",
  sigdig = 2,
  oerr = 3,
  exterr = FALSE,
  ranked = FALSE,
  i2i = TRUE,
  hide = NULL,
  omit = NULL,
  omit.col = NA,
  ...
)

## S3 method for class 'ReOs'
weightedmean(
  x,
  random.effects = FALSE,
  detect.outliers = TRUE,
  plot = TRUE,
  from = NA,
  to = NA,
  levels = NA,
  clabel = "",
  rect.col = c("#00FF0080", "#FF000080"),
  outlier.col = "#00FFFF80",
  sigdig = 2,
  oerr = 3,
  exterr = FALSE,
  ranked = FALSE,
  i2i = TRUE,
  hide = NULL,
  omit = NULL,
  omit.col = NA,
  ...
)

## S3 method for class 'SmNd'
weightedmean(
  x,
  random.effects = FALSE,
  detect.outliers = TRUE,
  plot = TRUE,
  from = NA,
  to = NA,
  levels = NA,
  clabel = "",
  rect.col = c("#00FF0080", "#FF000080"),
  outlier.col = "#00FFFF80",
  sigdig = 2,
  oerr = 3,
  exterr = FALSE,
  ranked = FALSE,
  i2i = TRUE,
  hide = NULL,
  omit = NULL,
  omit.col = NA,
  ...
)

## S3 method for class 'RbSr'
weightedmean(
  x,
  random.effects = FALSE,
  detect.outliers = TRUE,
  plot = TRUE,
  from = NA,
  to = NA,
  levels = NA,
  clabel = "",
  rect.col = c("#00FF0080", "#FF000080"),
  outlier.col = "#00FFFF80",
  sigdig = 2,
  oerr = 3,
  exterr = FALSE,
  i2i = TRUE,
  ranked = FALSE,
  hide = NULL,
  omit = NULL,
  omit.col = NA,
  ...
)

## S3 method for class 'LuHf'
weightedmean(
  x,
  random.effects = FALSE,
  detect.outliers = TRUE,
  plot = TRUE,
  from = NA,
  to = NA,
  levels = NA,
  clabel = "",
  rect.col = c("#00FF0080", "#FF000080"),
  outlier.col = "#00FFFF80",
  sigdig = 2,
  oerr = 3,
  exterr = FALSE,
  i2i = TRUE,
  ranked = FALSE,
  hide = NULL,
  omit = NULL,
  omit.col = NA,
  ...
)

## S3 method for class 'UThHe'
weightedmean(
  x,
  random.effects = FALSE,
  detect.outliers = TRUE,
  plot = TRUE,
  from = NA,
  to = NA,
  levels = NA,
  clabel = "",
  rect.col = c("#00FF0080", "#FF000080"),
  outlier.col = "#00FFFF80",
  sigdig = 2,
  oerr = 3,
  ranked = FALSE,
  hide = NULL,
  omit = NULL,
  omit.col = NA,
  ...
)

## S3 method for class 'fissiontracks'
weightedmean(
  x,
  random.effects = FALSE,
  detect.outliers = TRUE,
  plot = TRUE,
  from = NA,
  to = NA,
  levels = NA,
  clabel = "",
  rect.col = c("#00FF0080", "#FF000080"),
  outlier.col = "#00FFFF80",
  sigdig = 2,
  oerr = 3,
  exterr = FALSE,
  ranked = FALSE,
  hide = NULL,
  omit = NULL,
  omit.col = NA,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>a two column matrix of values (first column) and their
standard errors (second column) OR an object of class
<code>UPb</code>, <code>PbPb</code>, <code>ThPb</code>, <code>ArAr</code>, <code>KCa</code>,
<code>ReOs</code>, <code>SmNd</code>, <code>RbSr</code>, <code>LuHf</code>, <code>ThU</code>,
<code>fissiontracks</code> or <code>UThHe</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>optional arguments</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>from</code></td>
<td>
<p>minimum y-axis limit. Setting <code>from=NA</code> scales the
plot automatically.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>to</code></td>
<td>
<p>maximum y-axis limit. Setting <code>to=NA</code> scales the
plot automatically.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>random.effects</code></td>
<td>
<p>if <code>TRUE</code>, computes the weighted mean
using a random effects model with two parameters: the mean and
the dispersion. This is akin to a ‘model-3’ isochron
regression.
</p>
<p>if <code>FALSE</code>, attributes any excess dispersion to an
underestimation of the analytical uncertainties. This akin to a
‘model-1’ isochron regression.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>detect.outliers</code></td>
<td>
<p>logical flag indicating whether outliers
should be detected and rejected using Chauvenet's Criterion.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>plot</code></td>
<td>
<p>logical flag indicating whether the function should
produce graphical output or return numerical values to the
user.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>levels</code></td>
<td>
<p>a vector with additional values to be displayed as
different background colours of the plot symbols.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>clabel</code></td>
<td>
<p>label of the colour legend</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>rect.col</code></td>
<td>
<p>Fill colour for the measurements or age estimates. This can
either be a single colour or multiple colours to form a colour
ramp (to be used if <code>levels!=NA</code>):
</p>
<p>a single colour: <code>rgb(0,1,0,0.5)</code>, <code>'#FF000080'</code>,
<code>'white'</code>, etc.;
</p>
<p>multiple colours: <code>c(rbg(1,0,0,0.5)</code>,
<code>rgb(0,1,0,0.5))</code>, <code>c('#FF000080','#00FF0080')</code>,
<code>c('blue','red')</code>, <code>c('blue','yellow','red')</code>, etc.;
</p>
<p>a colour palette: <code>rainbow(n=100)</code>,
<code>topo.colors(n=100,alpha=0.5)</code>, etc.; or
</p>
<p>a reversed palette: <code>rev(topo.colors(n=100,alpha=0.5))</code>,
etc.
</p>
<p>For empty boxes, set <code>rect.col=NA</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>outlier.col</code></td>
<td>
<p>if <code>detect.outliers=TRUE</code>, the outliers are
given a different colour.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>sigdig</code></td>
<td>
<p>the number of significant digits of the numerical
values reported in the title of the graphical output.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>oerr</code></td>
<td>
<p>indicates whether the analytical uncertainties of the
output are reported in the plot title as:
</p>
<p><code>1</code>: 1<code class="reqn">\sigma</code> absolute uncertainties.
</p>
<p><code>2</code>: 2<code class="reqn">\sigma</code> absolute uncertainties.
</p>
<p><code>3</code>: absolute (1-<code class="reqn">\alpha</code>)% confidence intervals, where
<code class="reqn">\alpha</code> equales the value that is stored in
<code>settings('alpha')</code>.
</p>
<p><code>4</code>: 1<code class="reqn">\sigma</code> relative uncertainties (<code class="reqn">\%</code>).
</p>
<p><code>5</code>: 2<code class="reqn">\sigma</code> relative uncertainties (<code class="reqn">\%</code>).
</p>
<p><code>6</code>: relative (1-<code class="reqn">\alpha</code>)% confidence intervals, where
<code class="reqn">\alpha</code> equales the value that is stored in
<code>settings('alpha')</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ranked</code></td>
<td>
<p>plot the aliquots in order of increasing age?</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>hide</code></td>
<td>
<p>vector with indices of aliquots that should be removed
from the weighted mean plot.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>omit</code></td>
<td>
<p>vector with indices of aliquots that should be plotted
but omitted from the weighted mean calculation.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>omit.col</code></td>
<td>
<p>colour that should be used for the omitted
aliquots.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>type</code></td>
<td>
<p>scalar indicating whether to plot the
<code class="reqn">^{207}</code>Pb/<code class="reqn">^{235}</code>U age (<code>type</code>=1), the
<code class="reqn">^{206}</code>Pb/<code class="reqn">^{238}</code>U age (<code>type</code>=2), the
<code class="reqn">^{207}</code>Pb/<code class="reqn">^{206}</code>Pb age (<code>type</code>=3), the
<code class="reqn">^{207}</code>Pb/<code class="reqn">^{206}</code>Pb-<code class="reqn">^{206}</code>Pb/<code class="reqn">^{238}</code>U age
(<code>type</code>=4), the concordia_age (<code>type</code>=5), or the
<code class="reqn">^{208}</code>Pb/<code class="reqn">^{232}</code>Th age (<code>type</code>=6).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cutoff.76</code></td>
<td>
<p>the age (in Ma) below which the
<code class="reqn">^{206}</code>Pb/<code class="reqn">^{238}</code>U age and above which the
<code class="reqn">^{207}</code>Pb/<code class="reqn">^{206}</code>Pb age is used. This parameter is
only used if <code>type=4</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cutoff.disc</code></td>
<td>
<p>discordance cutoff filter. This is an object of
class <code>discfilter</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>exterr</code></td>
<td>
<p>propagate decay constant uncertainties?</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>common.Pb</code></td>
<td>
<p>common lead correction:
</p>
<p><code>0</code>: none
</p>
<p><code>1</code>: use the Pb-composition stored in
</p>
<p><code>settings('iratio','Pb207Pb206')</code> (if <code>x</code> has class
<code>UPb</code> and <code>x$format&lt;4</code>);
</p>
<p><code>settings('iratio','Pb206Pb204')</code> and
<code>settings('iratio','Pb207Pb204')</code> (if <code>x</code> has class
<code>PbPb</code> or <code>x</code> has class <code>UPb</code> and
<code>3&lt;x$format&lt;7</code>); or
</p>
<p><code>settings('iratio','Pb206Pb208')</code> and
<code>settings('iratio','Pb207Pb208')</code> (if <code>x</code> has class
<code>UPb</code> and <code>x$format=7</code> or <code>8</code>).
</p>
<p><code>2</code>: remove the common Pb by projecting the data along an
inverse isochron. Note: choosing this option introduces a degree of
circularity in the weighted age calculation. In this case the
weighted mean plot just serves as a way to visualise the residuals
of the data around the isochron, and one should be careful not to
over-interpret the numerical output.
</p>
<p><code>3</code>: use the Stacey-Kramers two-stage model to infer the
initial Pb-composition (only applicable if <code>x</code> has class
<code>UPb</code>)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Th0i</code></td>
<td>
<p>initial <code class="reqn">^{230}</code>Th correction.
</p>
<p><code>0</code>: no correction
</p>
<p><code>1</code>: project the data along an isochron fit
</p>
<p><code>2</code>: if <code>x$format</code> is <code>1</code> or <code>2</code>, correct the
data using the measured present day <code class="reqn">^{230}</code>Th/<code class="reqn">^{238}</code>U,
<code class="reqn">^{232}</code>Th/<code class="reqn">^{238}</code>U and <code class="reqn">^{234}</code>U/<code class="reqn">^{238}</code>U
activity ratios in the detritus. If <code>x$format</code> is <code>3</code> or
<code>4</code>, correct the data using the measured
<code class="reqn">^{238}</code>U/<code class="reqn">^{232}</code>Th activity ratio of the whole rock, as
stored in <code>x</code> by the <code>read.data()</code> function.
</p>
<p><code>3</code>: correct the data using an assumed initial
<code class="reqn">^{230}</code>Th/<code class="reqn">^{232}</code>Th-ratio for the detritus (only relevant
if <code>x$format</code> is <code>1</code> or <code>2</code>).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>i2i</code></td>
<td>
<p>‘isochron to intercept’: calculates the initial
(aka ‘inherited’, ‘excess’, or ‘common’) <code class="reqn">^{40}</code>Ar/<code class="reqn">^{36}</code>Ar,
<code class="reqn">^{40}</code>Ca/<code class="reqn">^{44}</code>Ca, <code class="reqn">^{207}</code>Pb/<code class="reqn">^{204}</code>Pb,
<code class="reqn">^{87}</code>Sr/<code class="reqn">^{86}</code>Sr, <code class="reqn">^{143}</code>Nd/<code class="reqn">^{144}</code>Nd,
<code class="reqn">^{187}</code>Os/<code class="reqn">^{188}</code>Os, <code class="reqn">^{230}</code>Th/<code class="reqn">^{232}</code>Th,
<code class="reqn">^{176}</code>Hf/<code class="reqn">^{177}</code>Hf or <code class="reqn">^{204}</code>Pb/<code class="reqn">^{208}</code>Pb
ratio from an isochron fit. Setting <code>i2i</code> to <code>FALSE</code> uses
the default values stored in <code>settings('iratio',...)</code>.
</p>
<p>Note that choosing this option introduces a degree of circularity
in the weighted age calculation. In this case the weighted mean
plot just serves as a way to visualise the residuals of the data
around the isochron, and one should be careful not to
over-interpret the numerical output.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>Let <code class="reqn">\{t_1, ..., t_n\}</code> be a set of n age estimates
determined on different aliquots of the same sample, and let
<code class="reqn">\{s[t_1], ..., s[t_n]\}</code> be their analytical
uncertainties. <code>IsoplotR</code> then calculates the weighted mean of
these data using one of two methods:
</p>

<ol>
<li>
<p> The ordinary error-weighted mean:
</p>
<p><code class="reqn">\mu = \sum(t_i/s[t_i]^2)/\sum(1/s[t_i]^2)</code>
</p>
</li>
<li>
<p> A random effects model with two sources of variance:
</p>
<p><code class="reqn">\log[t_i] \sim N(\log[\mu], \sigma^2 = (s[t_i]/t_i)^2 + \omega^2 )</code>
</p>
<p>where <code class="reqn">\mu</code> is the mean, <code class="reqn">\sigma^2</code> is the total variance
and <code class="reqn">\omega</code> is the 'overdispersion'. This equation can be
solved for <code class="reqn">\mu</code> and <code class="reqn">\omega</code> by the method of maximum
likelihood.
</p>
</li>
</ol>
<p>IsoplotR uses a modified version of Chauvenet's criterion for
outlier detection:
</p>

<ol>
<li>
<p> Compute the error-weighted mean (<code class="reqn">\mu</code>) of the <code class="reqn">n</code>
age determinations <code class="reqn">t_i</code> using their analytical uncertainties
<code class="reqn">s[t_i]</code>
</p>
</li>
<li>
<p> For each <code class="reqn">t_i</code>, compute the probability <code class="reqn">p_i</code> that
that <code class="reqn">|t-\mu|&gt;|t_i-\mu|</code> for <code class="reqn">t \sim N(\mu, s[t_i]^2 MSWD)</code>
(ordinary weighted mean) or <code class="reqn">\log[t] \sim
N(\log[\mu],s[t_i]^2+\omega^2)</code> (random effects model)
</p>
</li>
<li>
<p> Let <code class="reqn">p_j \equiv \min(p_1, ..., p_n)</code>. If
<code class="reqn">p_j&lt;0.05/n</code>, then reject the j<code class="reqn">^{th}</code> date, reduce <code class="reqn">n</code>
by one (i.e., <code class="reqn">n \rightarrow n-1</code>) and repeat steps 1 through 3
until the surviving dates pass the third step.  </p>
</li>
</ol>
<p>If the analytical uncertainties are small compared to the scatter
between the dates (i.e. if <code class="reqn">\omega \gg s[t]</code> for all <code class="reqn">i</code>),
then this generalised algorithm reduces to the conventional
Chauvenet criterion. If the analytical uncertainties are large and
the data do not exhibit any overdispersion, then the heuristic
outlier detection method is equivalent to Ludwig (2003)'s ‘2-sigma’
method.
</p>
<p>The uncertainty budget of the weighted mean does not include the
uncertainty of the initial daughter correction (if any). This
uncertainty is neither a purely systematic nor a purely random
uncertainty and cannot easily be propagated with conventional
geochronological data processing algorithms. This caveat is
especially pertinent to chronometers whose initial daughter
composition is determined by isochron regression. You may note that
the uncertainties of the weighted mean are usually much smaller
than those of the isochron. In this case the isochron errors are
more meaningful, and the weighted mean plot should just be used to
inspect the residuals of the data around the isochron.
</p>


<h3>Value</h3>

<p>Returns a list with the following items:
</p>

<dl>
<dt>mean</dt>
<dd>
<p>a two or three element vector with:
</p>
<p><code>t</code>: the weighted mean. An asterisk is added to the plot title
if the initial daughter correction is based on an isochron
regression, to mark the circularity of using an isochron to compute
a weighted mean.
</p>
<p><code>s[t]</code>: the standard error of the weighted mean, excluding the
uncertainty of the initial daughter correction.  This is because
this uncertainty is neither purely random nor purely systematic.
</p>
</dd>
<dt>disp</dt>
<dd>
<p>a two-element vector with the (over)dispersion and its
standard error.</p>
</dd>
<dt>mswd</dt>
<dd>
<p>the Mean Square of the Weighted Deviates
(a.k.a. ‘reduced Chi-square’ statistic)</p>
</dd>
<dt>df</dt>
<dd>
<p>the number of degrees of freedom of the Chi-square test
for homogeneity (<code class="reqn">df=n-1</code>, where <code class="reqn">n</code> is the number of
samples).</p>
</dd>
<dt>p.value</dt>
<dd>
<p>the p-value of a Chi-square test with <code class="reqn">df</code>
degrees of freedom, testing the null hypothesis that the underlying
population is not overdispersed.</p>
</dd>
<dt>valid</dt>
<dd>
<p>vector of logical flags indicating which steps are
included into the weighted mean calculation</p>
</dd>
<dt>plotpar</dt>
<dd>
<p>list of plot parameters for the weighted mean
diagram, including <code>mean</code> (the mean value), <code>ci</code> (a grey
rectangle with the (1 s.e., 2 s.e. or 100[1-<code class="reqn">\alpha</code>]%,
depending on the value of <code>oerr</code>) confidence interval ignoring
systematic errors), <code>ci.exterr</code> (a grey rectangle with the
confidence interval including systematic errors), <code>dash1</code> and
<code>dash2</code> (lines marking the confidence interval augmented by
<code class="reqn">\sqrt{mswd}</code> overdispersion if <code>random.effects=FALSE</code>),
and marking the confidence limits of a normal distribution whose
standard deviation equals the overdispersion parameter if
<code>random.effects=TRUE</code>). </p>
</dd>
</dl>
<h3>See Also</h3>

<p><code>central</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">ages &lt;- c(251.9,251.59,251.47,251.35,251.1,251.04,250.79,250.73,251.22,228.43)
errs &lt;- c(0.28,0.28,0.63,0.34,0.28,0.63,0.28,0.4,0.28,0.33)
weightedmean(cbind(ages,errs))

attach(examples)
weightedmean(LudwigMean)
</code></pre>


</div>