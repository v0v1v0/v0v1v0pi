<div class="container">

<table style="width: 100%;"><tr>
<td>component_distribution</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Connected components of a graph</h2>

<h3>Description</h3>

<p>Calculate the maximal (weakly or strongly) connected components of a graph
</p>


<h3>Usage</h3>

<pre><code class="language-R">component_distribution(graph, cumulative = FALSE, mul.size = FALSE, ...)

largest_component(graph, mode = c("weak", "strong"))

components(graph, mode = c("weak", "strong"))

is_connected(graph, mode = c("weak", "strong"))

count_components(graph, mode = c("weak", "strong"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>graph</code></td>
<td>
<p>The graph to analyze.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cumulative</code></td>
<td>
<p>Logical, if TRUE the cumulative distirubution (relative
frequency) is calculated.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>mul.size</code></td>
<td>
<p>Logical. If TRUE the relative frequencies will be multiplied
by the cluster sizes.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>Additional attributes to pass to <code>cluster</code>, right now only
<code>mode</code> makes sense.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>mode</code></td>
<td>
<p>Character string, either “weak” or “strong”.  For
directed graphs “weak” implies weakly, “strong” strongly
connected components to search. It is ignored for undirected graphs.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p><code>is_connected()</code> decides whether the graph is weakly or strongly
connected. The null graph is considered disconnected.
</p>
<p><code>components()</code> finds the maximal (weakly or strongly) connected components
of a graph.
</p>
<p><code>count_components()</code> does almost the same as <code>components()</code> but returns only
the number of clusters found instead of returning the actual clusters.
</p>
<p><code>component_distribution()</code> creates a histogram for the maximal connected
component sizes.
</p>
<p><code>largest_component()</code> returns the largest connected component of a graph. For
directed graphs, optionally the largest weakly or strongly connected component.
In case of a tie, the first component by vertex ID order is returned. Vertex
IDs from the original graph are not retained in the returned graph.
</p>
<p>The weakly connected components are found by a simple breadth-first search.
The strongly connected components are implemented by two consecutive
depth-first searches.
</p>


<h3>Value</h3>

<p>For <code>is_connected()</code> a logical constant.
</p>
<p>For <code>components()</code> a named list with three components:
</p>
<table>
<tr style="vertical-align: top;">
<td><code>membership</code></td>
<td>
<p>numeric vector giving the cluster id to which each vertex
belongs.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>csize</code></td>
<td>
<p>numeric vector giving the sizes of the clusters.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>no</code></td>
<td>
<p>numeric constant, the number of clusters.</p>
</td>
</tr>
</table>
<p>For <code>count_components()</code> an integer constant is returned.
</p>
<p>For <code>component_distribution()</code> a numeric vector with the relative
frequencies. The length of the vector is the size of the largest component
plus one. Note that (for currently unknown reasons) the first element of the
vector is the number of clusters of size zero, so this is always zero.
</p>
<p>For <code>largest_component()</code> the largest connected component of the graph.
</p>


<h3>Related documentation in the C library</h3>

<p><a href="https://igraph.org/c/html/latest/igraph-Structural.html#igraph_is_connected"><code>igraph_is_connected()</code></a>.</p>


<h3>Author(s)</h3>

<p>Gabor Csardi <a href="mailto:csardi.gabor@gmail.com">csardi.gabor@gmail.com</a>
</p>


<h3>See Also</h3>

<p><code>decompose()</code>, <code>subcomponent()</code>, <code>groups()</code>
</p>
<p>Connected components
<code>articulation_points()</code>,
<code>biconnected_components()</code>,
<code>decompose()</code>,
<code>is_biconnected()</code>
</p>
<p>Other structural.properties: 
<code>bfs()</code>,
<code>connect()</code>,
<code>constraint()</code>,
<code>coreness()</code>,
<code>degree()</code>,
<code>dfs()</code>,
<code>distance_table()</code>,
<code>edge_density()</code>,
<code>feedback_arc_set()</code>,
<code>girth()</code>,
<code>is_acyclic()</code>,
<code>is_dag()</code>,
<code>is_matching()</code>,
<code>k_shortest_paths()</code>,
<code>knn()</code>,
<code>reciprocity()</code>,
<code>subcomponent()</code>,
<code>subgraph()</code>,
<code>topo_sort()</code>,
<code>transitivity()</code>,
<code>unfold_tree()</code>,
<code>which_multiple()</code>,
<code>which_mutual()</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">
g &lt;- sample_gnp(20, 1 / 20)
clu &lt;- components(g)
groups(clu)
largest_component(g)
</code></pre>


</div>