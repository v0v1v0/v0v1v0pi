<div class="container">

<table style="width: 100%;"><tr>
<td>get_nbCluster_range</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>
Control of number of components in Gaussian mixture modelling
</h2>

<h3>Description</h3>

<p>These functions implement the default values for the number of components tried in Gaussian mixture modelling (matching the <code>nbCluster</code> argument of <code>Rmixmod::mixmodCluster()</code>). <code>get_nbCluster_range</code> allows the user to reproduce the internal rules used by <span class="pkg">Infusion</span> to determine this argument. <code>seq_nbCluster</code> is a wrapper to the function defined by the <code>seq_nbCluster</code> global option of the package. Its default result is a sequence of integers determined by the number of rows of the data (see <code>Infusion.options</code>). <code>get_nbCluster_range()</code> further checks the feasibility of the values generated by <code>seq_nbCluster())</code>, using additional criteria involving the number of columns of the data to determine the maximum feasible number of clusters. This maximum is controlled by the function defined by the <code>maxnbCluster</code> global option of the package. 
</p>
<p><code>refine_nbCluster</code> controls the default number of clusters of <code>refine</code>: it gets the range from <code>seq_nbCluster</code> and keeps only the maximum value of this range if this maximum is higher than the <code>onlymax</code> argument.
</p>
<p>Adventurous users can change the rules used by <span class="pkg">Infusion</span> by changing the global options <code>seq_nbCluster</code> and <code>maxnbCluster</code> (while conforming to the interfaces of these functions). Less ambitiously, they can for example use the maximum value of the result of <code>get_nbCluster_range()</code> as a single reasonable value for the <code>nbCluster</code> argument of <code>infer_SLik_joint</code>.
</p>


<h3>Usage</h3>

<pre><code class="language-R">seq_nbCluster(nr)
refine_nbCluster(nr, onlymax=7)
get_nbCluster_range(projdata, nr = nrow(projdata), nc = ncol(projdata), 
                    nbCluster = seq_nbCluster(nr), verbose=TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>projdata</code></td>
<td>
<p>data frame: the data to be clustered, which typically include parameters and <b>projected</b> summary statistics;</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nr</code></td>
<td>
<p>integer: number of rows of the data to be clustered;</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>onlymax</code></td>
<td>
<p>integer: see Description;</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nc</code></td>
<td>
<p>integer: number of columns of the data to be clustered, typically <b>twice</b> the number of estimated parameters;</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nbCluster</code></td>
<td>
<p>integer or vector of integers: candidate values, which feasability is checked by the function.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>verbose</code></td>
<td>
<p>boolean. Whether to print some information, or not.</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p> An integer vector</p>


<h3>Examples</h3>

<pre><code class="language-R"># Determination of number of clusters when attempting to estimate 
#   20 parameters from a reference table with 30000 rows:
seq_nbCluster(nr=30000L)
get_nbCluster_range(nr=30000L, nc=40L) # nc = *twice* the number of parameters
</code></pre>


</div>