<div class="container">

<table style="width: 100%;"><tr>
<td>plot.ICEuncrt</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>
Display Scatter for a possibly Transformed Bootstrap Distribution of ICE Uncertainty
</h2>

<h3>Description</h3>

<p>Assuming x is an output list object of class ICEuncrt, the default invocation of plot(x)
graphically displays the bootstrap distrib of ICE uncertainty currently stored in x.  An
invocation of the form x10 &lt;- plot(x, lfact=10) increases the value of x item lambda by a factor
of 10, displays that transformed bootstrap distribution, and stores it in object x10.  When
the x item unit is cost, an invocation of the form xs &lt;- plot(x, swu=TRUE) displays the bootstrap
distribution stored in x using effe units and stores the transformed distribution in object
xs.  
</p>


<h3>Usage</h3>

<pre><code class="language-R"> ## S3 method for class 'ICEuncrt'
plot(x, lfact = 1, swu = FALSE, alibi = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>Output list object of class ICEuncrt.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lfact</code></td>
<td>
<p>Positive factor multiplying the stored value of x item lambda.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>swu</code></td>
<td>
<p>Logical value of TRUE or FALSE to control switching the stored value of
x item unit between the 2 possibilities, cost and effe.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>alibi</code></td>
<td>
<p>Logical value of TRUE or FALSE to control scaling of axes.  alibi = FALSE
produces the default alias graphic in which points in the bootstrap uncertainty scatter are
held fixed in space, and changes in lambda merely change the scaling (tick marks) along either
the horizontal axis of a cost unit display or else along the vertical axis of an effe unit
display.  alibi = TRUE produces an alibi graphic in which the scaling (and range) is the
same along both axes, and changes in lambda cause the points in the bootstrap uncertainty
scatter to literally move either left or right in a cost unit display or else up or dowm in
an effe unit display.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>Optional argument(s) passed on to plot().</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>After a single call to ICEuncrt() for an initial value of the Shadow Price of Health,
lambda, and an initial choice of display unit (cost or effe), multiple calls to
plot.ICEuncrt() are usually made.  Alternative economic choices for lambda can be suggested
by making calls to ICEscale() with different values for lambda.  Because the Bootstrap
Distribution of ICE Uncertainty is equivariant under changes in lambda, it is much faster to
transform an existing bootstrap distribution than to generate a new one for a different value
of lambda.  The print.ICEuncrt() and plot.ICEuncrt() functions thus have 2 special parameters,
lfact and swa, that can change lambda and switch the units of measurement, respectively, without
actually regenerating the bootstrap distribution via a call to ICEuncrt(). 
</p>


<h3>Value</h3>

<p>Object of class ICEuncrt containing a possibly TRANSFORMED output list with items:
</p>
<table>
<tr style="vertical-align: top;">
<td><code>df</code></td>
<td>
<p>Saved value of the name of the data.frame in the original call to ICEuncrt().</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lambda</code></td>
<td>
<p>Possibly changed, positive value of lfact * (x item lambda).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>unit</code></td>
<td>
<p>Possibly switched value of x item unit, cost or effe.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>R</code></td>
<td>
<p>Saved integer value for number of bootstrap replications input to ICEuncrt.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>trtm</code></td>
<td>
<p>Saved name of the treatment indicator within the df data.frame.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>xeffe</code></td>
<td>
<p>Saved name of the treatment effectiveness variable within the df data.frame.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ycost</code></td>
<td>
<p>Saved name of the treatment cost variable within the df data.frame.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>effcst</code></td>
<td>
<p>Saved value of the sorted 3-variable (trtm,effe,cost) data.frame.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>t1</code></td>
<td>
<p>Observed value of (DeltaEffe, DeltaCost) when each patient is included exactly once.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>tb</code></td>
<td>
<p>R x 2 matrix of values of (DeltaEffe, DeltaCost) computed by transformation.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>seed</code></td>
<td>
<p>Saved value of the seed used to start pseudo random number generation.</p>
</td>
</tr>
</table>
<h3>Author(s)</h3>

<p>Bob Obenchain &lt;softrx@iquest.net&gt;</p>


<h3>References</h3>

<p>Obenchain RL.  Issues and algorithms in cost-effectiveness inference.  <em>Biopharmaceutical
Reports</em> 1997; <b>5(2)</b>: 1-7.  Washington, DC: American Statistical Association.
</p>
<p>Obenchain RL.  Resampling and multiplicity in cost-effectiveness inference.  <em>Journal of
Biopharmaceutical Statistics</em> 1999; <b>9(4)</b>: 563â€“582.
</p>
<p>Cook JR, Heyse JF.  Use of an angular transformation for ratio estimation in cost-effectiveness
analysis.  <em>Statistics in Medicine</em>  2000; <b>19</b>: 2989-3003.
</p>


<h3>See Also</h3>

<p><code>ICEuncrt</code>, <code>ICEscale</code> and <code>ICEwedge</code>.</p>


<h3>Examples</h3>

<pre><code class="language-R">  data(dpunc)
  dpunc
  # Transformation of a bootstrap distribution is fast.
  dpuncs &lt;- plot(dpunc, swu=TRUE)
</code></pre>


</div>