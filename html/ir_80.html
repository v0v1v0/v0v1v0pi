<div class="container">

<table style="width: 100%;"><tr>
<td>slice</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Subset rows in <code>ir</code> objects using their positions</h2>

<h3>Description</h3>

<p>Subset rows in <code>ir</code> objects using their positions
</p>


<h3>Usage</h3>

<pre><code class="language-R">slice.ir(.data, ..., .preserve = FALSE)

slice_sample.ir(.data, ..., n, prop, weight_by = NULL, replace = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>.data</code></td>
<td>
<p>An object of class <code>ir</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>For <code>slice()</code>: &lt;<code>data-masking</code>&gt; Integer row
values.
</p>
<p>Provide either positive values to keep, or negative values to drop.
The values provided must be either all positive or all negative.
Indices beyond the number of rows in the input are silently ignored.
</p>
<p>For <code>slice_helpers()</code>, these arguments are passed on to methods.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>.preserve</code></td>
<td>
<p>Relevant when the <code>.data</code> input is grouped.
If <code>.preserve = FALSE</code> (the default), the grouping structure
is recalculated based on the resulting data, otherwise the grouping is kept as is.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>n, prop</code></td>
<td>
<p>Provide either <code>n</code>, the number of rows, or <code>prop</code>, the
proportion of rows to select. If neither are supplied, <code>n = 1</code> will be
used.
</p>
<p>If a negative value of <code>n</code> or <code>prop</code> is provided, the specified number or
proportion of rows will be removed.
</p>
<p>If <code>n</code> is greater than the number of rows in the group (or <code>prop &gt; 1</code>),
the result will be silently truncated to the group size. If the
<code>prop</code>ortion of a group size does not yield an integer number of rows, the
absolute value of <code>prop*nrow(.data)</code> is rounded down.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>weight_by</code></td>
<td>
<p>Sampling weights. This must evaluate to a vector of
non-negative numbers the same length as the input. Weights are
automatically standardised to sum to 1.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>replace</code></td>
<td>
<p>Should sampling be performed with (<code>TRUE</code>) or without
(<code>FALSE</code>, the default) replacement.</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p><code>.data</code> with subsetted rows.
</p>


<h3>Source</h3>

<p><code>dplyr::slice()</code>
</p>


<h3>See Also</h3>

<p>Other tidyverse: 
<code>arrange.ir()</code>,
<code>distinct.ir()</code>,
<code>extract.ir()</code>,
<code>filter-joins</code>,
<code>filter.ir()</code>,
<code>group_by</code>,
<code>mutate-joins</code>,
<code>mutate</code>,
<code>nest</code>,
<code>pivot_longer.ir()</code>,
<code>pivot_wider.ir()</code>,
<code>rename</code>,
<code>rowwise.ir()</code>,
<code>select.ir()</code>,
<code>separate.ir()</code>,
<code>separate_rows.ir()</code>,
<code>summarize</code>,
<code>unite.ir()</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">## slice
dplyr::slice(ir_sample_data, 1:5)
dplyr::slice_min(ir_sample_data, holocellulose, n = 3)
dplyr::slice_max(ir_sample_data, holocellulose, n = 3)
dplyr::slice_head(ir_sample_data, n = 5)
dplyr::slice_tail(ir_sample_data, n = 5)

## slice_sample
set.seed(234)
dplyr::slice_sample(ir_sample_data, n = 3)


</code></pre>


</div>