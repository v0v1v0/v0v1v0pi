<div class="container">

<table style="width: 100%;"><tr>
<td>run.anchor</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Run anchor alignment on the main data.</h2>

<h3>Description</h3>

<p>This function takes an object of class iCellR and runs anchor alignment. It's a wrapper for Seurat.
</p>


<h3>Usage</h3>

<pre><code class="language-R">run.anchor(
  x = NULL,
  method = "base.mean.rank",
  top.rank = 500,
  gene.list = "character",
  data.type = "main",
  normalization.method = "LogNormalize",
  scale.factor = 10000,
  margin = 1,
  block.size = NULL,
  selection.method = "vst",
  nfeatures = 2000,
  anchor.features = 2000,
  scale = TRUE,
  sct.clip.range = NULL,
  reduction = c("cca", "rpca"),
  l2.norm = TRUE,
  dims = 1:30,
  k.anchor = 5,
  k.filter = 200,
  k.score = 30,
  max.features = 200,
  nn.method = "rann",
  eps = 0,
  k.weight = 100
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>An object of class iCellR.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>method</code></td>
<td>
<p>Choose from "base.mean.rank" or "gene.model", default is "base.mean.rank". If gene.model is chosen you need to provide gene.list.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>top.rank</code></td>
<td>
<p>A number taking the top genes ranked by base mean, default = 500.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>gene.list</code></td>
<td>
<p>A charactor vector of genes to be used for PCA. If "clust.method" is set to "gene.model", default = "my_model_genes.txt".</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>data.type</code></td>
<td>
<p>Choose from "main" and "imputed", default = "main"</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>normalization.method</code></td>
<td>
<p>Choose from "LogNormalize", "CLR" and "RC". LogNormalize: Feature counts for each cell are divided by the total counts for that cell and multiplied by the scale.factor. This is then natural-log transformed using log1p. CLR: Applies a centered log ratio transformation. RC: Relative counts. Feature counts for each cell are divided by the total counts for that cell and multiplied by the scale.factor. No log-transformation is applied. For counts per million (CPM) set ‘scale.factor = 1e6’</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>scale.factor</code></td>
<td>
<p>Sets the scale factor for cell-level normalization.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>margin</code></td>
<td>
<p>If performing CLR normalization, normalize across features (1) or cells (2)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>block.size</code></td>
<td>
<p>How many cells should be run in each chunk, will try to split evenly across threads</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>selection.method</code></td>
<td>
<p>Choose from "vst","mean.var.plot (mvp)","dispersion (disp)".</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nfeatures</code></td>
<td>
<p>Number of features to select as top variable features; only used when ‘selection.method’ is set to ‘'dispersion'’ or ‘'vst'’</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>anchor.features</code></td>
<td>
<p>A numeric value. This will call ‘SelectIntegrationFeatures’ to select the provided number of features to be used in anchor finding</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>scale</code></td>
<td>
<p>Whether or not to scale the features provided. Only set to FALSE if you have previously scaled the features you want to use for each object in the object.list</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>sct.clip.range</code></td>
<td>
<p>Numeric of length two specifying the min and max values the Pearson residual will be clipped to</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>reduction</code></td>
<td>
<p>cca: Canonical correlation analysis. rpca: Reciprocal PCA</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>l2.norm</code></td>
<td>
<p>Perform L2 normalization on the CCA cell embeddings after dimensional reduction</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>dims</code></td>
<td>
<p>Which dimensions to use from the CCA to specify the neighbor search space</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>k.anchor</code></td>
<td>
<p>How many neighbors (k) to use when picking anchors</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>k.filter</code></td>
<td>
<p>How many neighbors (k) to use when filtering anchors</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>k.score</code></td>
<td>
<p>How many neighbors (k) to use when scoring anchors</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>max.features</code></td>
<td>
<p>The maximum number of features to use when specifying the neighborhood search space in the anchor filtering</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nn.method</code></td>
<td>
<p>Method for nearest neighbor finding. Options include: rann, annoy</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>eps</code></td>
<td>
<p>Error bound on the neighbor finding algorithm (from RANN)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>k.weight</code></td>
<td>
<p>Number of neighbors to consider when weighting</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p>An object of class iCellR.
</p>


</div>