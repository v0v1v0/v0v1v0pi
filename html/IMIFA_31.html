<div class="container">

<table style="width: 100%;"><tr>
<td>get_IMIFA_results</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Extract results, conduct posterior inference and compute performance metrics for MCMC samples of models from the IMIFA family</h2>

<h3>Description</h3>

<p>This function post-processes simulations generated by <code>mcmc_IMIFA</code> for any of the IMIFA family of models. This includes accounting for label switching, and accounting for rotational invariance via Procrustean methods. It can be re-ran at little computational cost in order to extract different models explored by the sampler used for <code>sims</code>, without having to re-run the model itself. New results objects using different numbers of clusters and different numbers of factors (if visited by the model in question), or using different model selection criteria (if necessary) can be generated with ease. Posterior predictive checking of the appropriateness of the fitted model is also facilitated.
</p>


<h3>Usage</h3>

<pre><code class="language-R">get_IMIFA_results(sims = NULL,
                  burnin = 0L,
                  thinning = 1L,
                  G = NULL,
                  Q = NULL,
                  criterion = c("bicm", "aicm", "dic", "bic.mcmc", "aic.mcmc"),
                  adapt = FALSE,
                  G.meth = c("mode", "median"),
                  Q.meth = c("mode", "median"),
                  conf.level = 0.95,
                  error.metrics = TRUE,
                  vari.rot = FALSE,
                  z.avgsim = FALSE,
                  zlabels = NULL,
                  nonempty = TRUE,
                  ...)

## S3 method for class 'Results_IMIFA'
print(x,
      ...)

## S3 method for class 'Results_IMIFA'
summary(object,
        MAP = TRUE,
        ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>sims</code></td>
<td>
<p>An object of class <code>"IMIFA"</code> generated by <code>mcmc_IMIFA</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>burnin</code></td>
<td>
<p>Optional additional number of iterations to discard. Defaults to 0, corresponding to no additional burnin. See <code>mixfaControl</code> for the default <code>burnin</code> settings used previously by <code>mcmc_IMIFA</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>thinning</code></td>
<td>
<p>Optional interval for extra thinning to be applied. Defaults to 1, corresponding to no additional thinning. See <code>mixfaControl</code> for the default <code>thinning</code> settings used previously by <code>mcmc_IMIFA</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>G</code></td>
<td>
<p>If this argument is not specified, results will be returned with the optimal number of clusters. If different numbers of clusters were explored in <code>sims</code> for the <code>"MFA"</code> or <code>"MIFA"</code> methods, supplying an integer value allows pulling out a specific solution with <code>G</code> clusters, even if the solution is sub-optimal.
</p>
<p>Similarly, this allows retrieval of samples corresponding to a solution, if visited, with <code>G</code> clusters for the <code>"OMFA"</code>, <code>"OMIFA"</code>, <code>"IMFA"</code> and <code>"IMIFA"</code> methods.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Q</code></td>
<td>
<p>If this argument is not specified, results will be returned with the optimal number of factors. If different numbers of factors were explored in <code>sims</code> for the <code>"FA"</code>, <code>"MFA"</code>, <code>"OMFA"</code> or <code>"IMFA"</code> methods, this allows pulling out a specific solution with <code>Q</code> factors, even if the solution is sub-optimal.
</p>
<p>Similarly, this allows retrieval of samples corresponding to a solution, if visited, with <code>Q</code> factors for the <code>"IFA"</code>, <code>"MIFA"</code>, <code>"OMIFA"</code> and <code>"IMIFA"</code> methods if adaptation has already taken place. Can be supplied as a scalar or a vector of values for each cluster.
</p>
<p>If adaptation didn't take place during model-fitting, <code>adapt=TRUE</code> can be supplied here to determine the optimal cluster-specific numbers of non-redundant factors (see below).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>criterion</code></td>
<td>
<p>The criterion to use for model selection, where model selection is only required if more than one model was run under the <code>"FA"</code>, <code>"MFA"</code>, <code>"MIFA"</code>, <code>"OMFA"</code> or <code>"IMFA"</code> methods when <code>sims</code> was created via <code>mcmc_IMIFA</code>. Defaults to <code>bicm</code>, but note that these are <em>all</em> calculated; this argument merely indicates which one will form the basis of the construction of the output.
</p>
<p>Note that the first three options here might exhibit bias in favour of zero-factor models for the finite factor <code>"FA"</code>, <code>"MFA"</code>, <code>"OMFA"</code> and <code>"IMFA"</code> methods and might exhibit bias in favour of one-cluster models for the <code>"MFA"</code> and <code>"MIFA"</code> methods. The <code>aic.mcmc</code> and <code>bic.mcmc</code> criteria will only be returned for finite factor models.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>adapt</code></td>
<td>
<p>A logical indicating if adaptation should be applied to the stored loadings and scores matrices to truncate the cluster-specific number(s) of non-redundant factors. This argument is only relevant if <code>adapt=FALSE</code> was used when initially fitting the model (otherwise, adaptation has already taken place during sampling, by default), and hence defaults to <code>FALSE</code> here. Relevant parameters from <code>mgpControl</code> (namely <code>active.crit</code>, <code>eps</code>, <code>prop</code>, and <code>forceQg</code>) can be passed via the <code>...</code> construct, but will default to their values under <code>mgpControl</code> if not specified. Note that <code>adapt=TRUE</code> is only invoked if the relevant parameters were stored via <code>storeControl</code> when running the model: loadings only for <code>active.crit="BD"</code>, loadings and scores for <code>active.crit="SC"</code> for <code>"IFA"</code> models.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>G.meth</code></td>
<td>
<p>If the object in <code>sims</code> arises from the <code>"OMFA"</code>, <code>"OMIFA"</code>, <code>"IMFA"</code> or <code>"IMIFA"</code> methods, this argument determines whether the optimal number of clusters is given by the mode or median of the posterior distribution of <code>G</code>. Defaults to <code>"mode"</code>. Often the mode and median will agree in any case.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Q.meth</code></td>
<td>
<p>If the object in <code>sims</code> arises from the <code>"IFA"</code>, <code>"MIFA"</code>, <code>"OMIFA"</code> or <code>"IMIFA"</code> methods, this argument determines whether the optimal number of latent factors is given by the mode or median of the posterior distribution of <code>Q</code>. Defaults to <code>"mode"</code>. Often the mode and median will agree in any case.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>conf.level</code></td>
<td>
<p>The confidence level to be used throughout for credible intervals for all parameters of inferential interest, and error metrics if <code>error.metrics=TRUE</code>. Defaults to <code>0.95</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>error.metrics</code></td>
<td>
<p>A logical activating or deactivating posterior predictive checking: i.e. controlling whether metrics quantifying a) the posterior predictive reconstruction error (PPRE) between bin counts of the data and bin counts of replicate draws from the posterior distribution &amp; and b) the error between the empirical and estimated covariance matrices should be computed. These are computed for every <em>valid</em> retained iteration (see <code>Details</code>). Defaults to <code>TRUE</code>, but can be time-consuming for models which achieve clustering. These error metrics, and the uncertainty associated with them, can be visualised via <code>plot.Results_IMIFA</code>. Depending on what parameters were stored when calling <code>mcmc_IMIFA</code>, potentially not all error metrics will be available to compute.
</p>
<p>The Frobenius norm is used in the computation of the PPRE, by default, but the <code>type</code> of <code>norm</code> can be changed via the <code>...</code> construct below. So too can the breakpoints (<code>dbreaks</code>) used to bin the data and the posterior predictive replicate data sets. Some caution is advised in the latter case.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>vari.rot</code></td>
<td>
<p>Logical indicating whether the loadings matrix/matrices template(s) should be <code>varimax</code> rotated first, prior to the Procrustes rotation steps. Defaults to <code>FALSE</code>. Not necessary at all for clustering purposes, or inference on the covariance matrix, but useful if interpretable inferences on the loadings matrix/matrices are desired. Arguments to <code>varimax</code> can be passed via the <code>...</code> construct, but note that the argument <code>normalize</code> here defaults to <code>FALSE</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>z.avgsim</code></td>
<td>
<p>Logical (defaults to <code>FALSE</code>) indicating whether the clustering should also be summarised with a call to <code>Zsimilarity</code> by the clustering with minimum mean squared error to the similarity matrix obtained by averaging the stored adjacency matrices, in addition to the MAP estimate.
</p>
<p>Note that the MAP clustering is computed <em>conditional</em> on the estimate of the number of clusters (whether that be the modal estimate or the estimate according to <code>criterion</code>) and other parameters are extracted conditional on this estimate of <code>G</code>: however, in contrast, the number of distinct clusters in the summarised labels obtained by specifying <code>z.avgsim=TRUE</code> may not necessarily coincide with the MAP estimate of <code>G</code>, but it may provide a useful alternative summary of the partitions explored during the chain, and the user is free to call <code>get_IMIFA_results</code> again with the new suggested <code>G</code> value.
</p>
<p>Please be warned that this feature requires loading the <code>mcclust</code> package. This is liable to take considerable time to compute, and may not even be possible if the number of observations &amp;/or number of stored iterations is large and the resulting matrix isn't sufficiently sparse. When <code>z.avgsim=TRUE</code>, both the summarised clustering and the similarity matrix are stored: the latter can be visualised as part of a call to <code>plot.Results_IMIFA</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>zlabels</code></td>
<td>
<p>For any method that performs clustering, the true labels can be supplied if they are known in order to compute clustering performance metrics. This also has the effect of ordering the MAP labels (and thus the ordering of cluster-specific parameters) to most closely correspond to the true labels if supplied.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nonempty</code></td>
<td>
<p>For <code>"MFA"</code> and <code>"MIFA"</code> models ONLY: a logical indicating whether only iterations with non-empty components should be retained. Defaults to <code>TRUE</code>, but may lead to empty chains - conversely, <code>FALSE</code> may lead to empty components and related errors.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>x, object, MAP, ...</code></td>
<td>
<p>Arguments required for the <code>print.Results_IMIFA</code> and <code>summary.Results_IMIFA</code> functions: <code>x</code> and <code>object</code> are objects of class <code>"Results_IMIFA"</code> resulting from a call to <code>get_IMIFA_results</code>. <code>MAP</code> is a logical which governs whether a table of the MAP classification is printed, while <code>...</code> gathers additional arguments to those functions.
</p>
<p>Users can also pass the <code>type</code> argument to the <code>norm</code> function when <code>isTRUE(error.metrics)</code> and the posterior predictive reconstruction error (PPRE) is calculated. By default the Frobenius norm (<code>type="F"</code>) is employed.
</p>
<p>When <code>adapt=TRUE</code> here, relevant arguments from <code>mgpControl</code> (namely <code>active.crit</code>, <code>eps</code>, <code>prop</code>, and <code>forceQg</code>) can be supplied here too, though they retain their default values from <code>mgpControl</code> otherwise.
</p>
<p>Finally, the <code>...</code> construct also allows arguments to <code>varimax</code> to be passed to <code>get_IMIFA_results</code> itself, when <code>isTRUE(vari.rot)</code>, or arguments to <code>hist</code> when <code>isTRUE(error.metrics)</code>, in order to guide construction of the bins. Additionally, by passing the argument <code>dbreaks</code> via the <code>...</code> construct, the bins can be specified directly. However, caution is advised in doing so; in particular, the bins must be constructed on data which has been standardised in the same way as the data modelled within <code>mcmc_IMIFA</code>.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>The function also performs post-hoc corrections for label switching, as well as post-hoc Procrustes rotation of loadings matrices and scores, in order to ensure sensible posterior parameter estimates, computes error metrics, constructs credible intervals, and generally transforms the raw <code>sims</code> object into an object of class <code>"Results_IMIFA"</code> in order to prepare the results for plotting via <code>plot.Results_IMIFA</code>.
</p>
<p>For the infinite factor methods, iterations where the maximum number of factors was greater than or equal to the maximum of the estimated cluster-specific factors are retained for posterior summaries of the scores, in order to preserve the estimated dimension of the scores matrices. Similarly, these are also the <em>valid</em> iterations used for the computation of the averages and credible intervals for the error metrics. For the finite factor models, <em>all</em> retained iterations are used in both instances (i.e. both for the scores and the error metrics).
</p>
<p>In all cases, only iterations with <code>G</code> non-empty components are retained.
</p>


<h3>Value</h3>

<p>An object of class <code>"Results_IMIFA"</code> to be passed to <code>plot.Results_IMIFA</code> for visualising results. Dedicated <code>print</code> and <code>summary</code> functions also exist for objects of this class. The object, say <code>x</code>, is a list of lists, the most important components of which are:
</p>
<table>
<tr style="vertical-align: top;">
<td><code>Clust</code></td>
<td>
<p>Everything pertaining to clustering performance can be found here for all but the <code>"FA"</code> and <code>"IFA"</code> methods (or models where the estimate number of clusters is 1), in particular <code>x$Clust$MAP</code>, the MAP summary of the posterior clustering, the last valid sample of cluster labels <code>x$Clust$last.z</code>, the matrix of posterior cluster membership probabilities <code>x$Clust$post.prob</code>, and the posterior confusion matrix <code>x$Clust$PCM</code>.
</p>
<p>More detail is given if known <code>zlabels</code> are supplied: performance is always evaluated against the MAP clustering, with additional evaluation against the alternative clustering computed if <code>z.avgsim=TRUE</code>. Posterior summaries of the mixing proportions, and the concentration/discount parameters, if necessary, are also included here, as well as the last valid samples of each.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Error</code></td>
<td>
<p>Everything pertaining the model fit assessment can be found here, incl. the distribution of the PPRE values and associated bin counts for the replicate draws, as well as average error metrics (e.g. MSE, RMSE), and credible intervals quantifying the associated uncertainty, between the empirical and estimated covariance matrix/matrices, both of which are also included.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>GQ.results</code></td>
<td>
<p>Everything pertaining to model choice can be found here, incl. posterior summaries for the estimated number of clusters and estimated number of factors, if applicable to the method employed. Model selection criterion values are also accessible here.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Means</code></td>
<td>
<p>Posterior summaries for the means, after conditioning on <code>G</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Loadings</code></td>
<td>
<p>Posterior summaries for the factor loadings matrix/matrices, after conditioning on <code>G</code> and <code>Q</code>. Posterior mean loadings given by <code>x$Loadings$post.load</code> are given the <code>loadings</code> class for printing purposes and thus the manner in which they are displayed can be modified.
</p>
<p>The number of iterations retained for posterior summaries of the loadings may vary for different clusters for the infinite factor methods, corresponding to iterations where the cluster-specific number of factors was greater than or equal to the modal estimate of the cluster-specific number of factors.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Scores</code></td>
<td>
<p>Posterior summaries for the latent factor scores, after conditioning on the maximum of the estimated number of cluster-specific factors. Summaries are given for the <em>single</em> matrix of factor scores. See <code>scores_MAP</code> to decompose these summaries into sub-matrices according to the MAP partition (for models which achieve clustering).
</p>
<p>For the infinite factor methods, iterations where the maximum number of factors was greater than or equal to the maximum of the estimated cluster-specific factors are retained for posterior summaries of the scores, in order to preserve the estimated dimension of the scores matrices.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>Uniquenesses</code></td>
<td>
<p>Posterior summaries for the uniquenesses, after conditioning on <code>G</code>.</p>
</td>
</tr>
</table>
<p>The objects <code>Means</code>, <code>Loadings</code>, <code>Scores</code> and <code>Uniquenesses</code> (if stored when calling <code>mcmc_IMIFA</code>!) also contain, as well as the posterior summaries, the entire chain of valid samples of each, as well as, for convenience, the last valid samples of each (after conditioning on the modal <code>G</code> and <code>Q</code> values, and accounting for label switching, and rotational invariance via Procrustes rotation).
</p>


<h3>Note</h3>

<p>For the <code>"IMIFA"</code>, <code>"IMFA"</code>, <code>"OMIFA"</code>, and <code>"OMFA"</code> methods, the retained mixing proportions are renormalised after conditioning on the modal <code>G</code>. This is especially necessary for the computation of the <code>error.metrics</code>, just note that the values on which posterior inference are conducted will ever so slightly differ from the actually sampled values.
</p>
<p>Due to the way the offline label-switching correction is performed, different runs of this function may give <em>very slightly</em> different results in terms of the cluster labellings (and by extension the parameters, which are permuted in the same way), but only if the chain was run for an extremely small number of iterations, well below the number required for convergence, and samples of the cluster labels match poorly across iterations (particularly if the number of clusters suggested by those sampled labels is high).
</p>


<h3>Author(s)</h3>

<p>Keefe Murphy - &lt;<a href="mailto:keefe.murphy@mu.ie">keefe.murphy@mu.ie</a>&gt;
</p>


<h3>References</h3>

<p>Murphy, K., Viroli, C., and Gormley, I. C. (2020) Infinite mixtures of infinite factor analysers, <em>Bayesian Analysis</em>, 15(3): 937-963. &lt;<a href="https://doi.org/10.1214/19-BA1179">doi:10.1214/19-BA1179</a>&gt;.
</p>


<h3>See Also</h3>

<p><code>plot.Results_IMIFA</code>, <code>mcmc_IMIFA</code>, <code>Zsimilarity</code>, <code>scores_MAP</code>, <code>sim_IMIFA_model</code>, <code>Procrustes</code>, <code>varimax</code>, <code>norm</code>, <code>mgpControl</code>, <code>storeControl</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R"># data(coffee)
# data(olive)

# Run a MFA model on the coffee data over a range of clusters and factors.
# simMFAcoffee  &lt;- mcmc_IMIFA(coffee, method="MFA", range.G=2:3, range.Q=0:3, n.iters=1000)

# Accept all defaults to extract the optimal model.
# resMFAcoffee  &lt;- get_IMIFA_results(simMFAcoffee)

# Instead let's get results for a 3-cluster model, allowing Q be chosen by aic.mcmc.
# resMFAcoffee2 &lt;- get_IMIFA_results(simMFAcoffee, G=3, criterion="aic.mcmc")

# Run an IMIFA model on the olive data, accepting all defaults.
# simIMIFAolive &lt;- mcmc_IMIFA(olive, method="IMIFA", n.iters=10000)

# Extract optimum results
# Estimate G &amp; Q by the median of their posterior distributions
# Construct 90% credible intervals and try to return the similarity matrix.
# resIMIFAolive &lt;- get_IMIFA_results(simIMIFAolive, G.meth="median", Q.meth="median",
#                                    conf.level=0.9, z.avgsim=TRUE)
# summary(resIMIFAolive)

# Simulate new data from the above model
# newdata       &lt;- sim_IMIFA_model(resIMIFAolive)

# Fit an IFA model without adaptation and examine results with and without post-hoc adaptation
# Use the "SC" criterion for determining the number of active factors
# simIFAnoadapt   &lt;- mcmc_IMIFA(olive, method="IFA", n.iters=10000, adapt=FALSE)
# resIFAnoadapt   &lt;- get_IMIFA_results(simIFAnoadapt)
# resIFApostadapt &lt;- get_IMIFA_results(simIFAnoadapt, adapt=TRUE, active.crit="SC")

# Compare to an IFA model with adaptive Gibbs sampling
# simIFAadapt     &lt;- mcmc_IMIFA(coffee, method="IFA", n.iters=10000, active.crit="BD")
# resIFAadapt     &lt;- get_IMIFA_results(simIFAadapt)
# plot(resIFAnoadapt, "GQ")
# plot(resIFApostadapt, "GQ")
# plot(resIFAadapt, "GQ")
</code></pre>


</div>