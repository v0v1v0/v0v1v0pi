<div class="container">

<table style="width: 100%;"><tr>
<td>curvIPEC</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>
RMS Curvature Calculation Function
</h2>

<h3>Description</h3>

<p>Calculates the root mean square curvatures (intrinsic and parameter-effects curvatures) 
of a nonlinear regression model.
</p>


<h3>Usage</h3>

<pre><code class="language-R">curvIPEC(expr, theta, x, y, tol = 1e-16, alpha = 0.05, method = "Richardson", 
         method.args = list(eps = 1e-04, d = 0.11, 
         zero.tol = sqrt(.Machine$double.eps/7e-07), 
         r = 6, v = 2, show.details = FALSE), side = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>expr</code></td>
<td>
<p>A given parametric model</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>theta</code></td>
<td>
<p>A vector of parameters of the model</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>A vector or matrix of observations of independent variable(s)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>y</code></td>
<td>
<p>A vector of observations of response variable</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>tol</code></td>
<td>
<p>The tolerance for detecting linear dependencies in the columns of a matrix in the QR decomposition. 
See the input argument of <code>tol</code> of the <code>qr</code> function in package <span class="pkg">base</span> </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>alpha</code></td>
<td>
<p>Parameter controlling the significance level for testing the significance of a curvature</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>method</code></td>
<td>
<p>It is the same as the input argument of <code>method</code> of the <code>hessian</code> function in package <span class="pkg">numDeriv</span></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>method.args</code></td>
<td>
<p>It is the same as the input argument of <code>method.args</code> of the <code>hessian</code> function in package <span class="pkg">numDeriv</span></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>side</code></td>
<td>
<p>It is the same as the input argument of <code>side</code> of the <code>jacobian</code> function in package <span class="pkg">numDeriv</span></p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>This function was built based on the <code>hessian</code> and <code>jacobian</code> functions in package <span class="pkg">numDeriv</span>, 
with reference to the <code>rms.curv</code> function in package <span class="pkg">MASS</span>. 
However, it is more general without being limited by the <code>deriv3</code> function in package <span class="pkg">stats</span> 
and <code>nls</code> class like the <code>rms.curv</code> function in package <span class="pkg">MASS</span>. It mainly relies on package <span class="pkg">numDeriv</span>.
The users only need provide the defined model, the fitted parameter vector, and the observations 
of independent and response variables, they will obtain the curvatures. The input argument <code>theta</code> can be obtained using the <code>fitIPEC</code> 
function in the current package, and it also can be obtained using the other nonlinear regression functions.
</p>


<h3>Value</h3>

<table>
<tr style="vertical-align: top;">
<td><code>rms.ic</code></td>
<td>
<p>The root mean square intrinsic curvature</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>rms.pec</code></td>
<td>
<p>The root mean square parameter-effects curvature</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>critical.c</code></td>
<td>
<p>The critical curvature value</p>
</td>
</tr>
</table>
<h3>Note</h3>

<p>The calculation precision of curvature mainly depends on the setting of <code>method.args</code>. 
The two important default values in the list of <code>method.args</code> are <code>d = 0.11</code>, and <code>r = 6</code>.
</p>
<p>This function cannot be used to calculate the maximum intrinsic and parameter-effects curvatures.
</p>


<h3>Author(s)</h3>

<p>Peijian Shi <a href="mailto:pjshi@njfu.edu.cn">pjshi@njfu.edu.cn</a>, Peter M. Ridland <a href="mailto:p.ridland@unimelb.edu.au">p.ridland@unimelb.edu.au</a>, 
David A. Ratkowsky <a href="mailto:d.ratkowsky@utas.edu.au">d.ratkowsky@utas.edu.au</a>, Yang Li <a href="mailto:yangli@fau.edu">yangli@fau.edu</a>.
</p>


<h3>References</h3>

<p>Bates, D.M and Watts, D.G. (1988) <em>Nonlinear Regression Analysis and its Applications</em>. Wiley, New York. <a href="https://doi.org/10.1002/9780470316757">doi:10.1002/9780470316757</a>
</p>
<p>Gebremariam, B. (2014) Is nonlinear regression throwing you a curve? New diagnostic and inference tools in the NLIN Procedure. 
Paper SAS384-2014. <a href="http://support.sas.com/resources/papers/proceedings14/SAS384-2014.pdf">http://support.sas.com/resources/papers/proceedings14/SAS384-2014.pdf</a>
</p>
<p>Ratkowsky, D.A. (1983) <em>Nonlinear Regression Modeling: A Unified Practical Approach</em>. Marcel Dekker, New York.
</p>
<p>Ratkowsky, D.A. (1990) <em>Handbook of Nonlinear Regression Models</em>, Marcel Dekker, New York.
</p>
<p>Ratkowsky, D.A. &amp; Reddy, G.V.P. (2017) Empirical model with excellent statistical properties for describing temperature-dependent 
developmental rates of insects and mites. <em>Ann. Entomol. Soc. Am.</em> 110, 302<code class="reqn">-</code>309. <a href="https://doi.org/10.1093/aesa/saw098">doi:10.1093/aesa/saw098</a>
</p>


<h3>See Also</h3>

<p><code>derivIPEC</code>, <code>hessian</code> in package <span class="pkg">numDeriv</span>, 
<code>jacobian</code> in package <span class="pkg">numDeriv</span>, <code>rms.curv</code> in package <span class="pkg">MASS</span>
</p>


<h3>Examples</h3>

<pre><code class="language-R">#### Example 1 ##################################################################################
# The velocity of the reaction (counts/min^2) under different substrate concentrations 
#   in parts per million (ppm) (Pages 255 and 269 of Bates and Watts 1988)

x1 &lt;- c(0.02, 0.02, 0.06, 0.06, 0.11, 0.11, 0.22, 0.22, 0.56, 0.56, 1.10, 1.10)
y1 &lt;- c(76, 47, 97, 107, 123, 139, 159, 152, 191, 201, 207, 200)

# Define the Michaelis-Menten model
MM &lt;- function(theta, x){
    theta[1]*x / ( theta[2] + x )    
}

par1 &lt;- c(212.68490865, 0.06412421)
# To calculate curvatures
res2 &lt;- curvIPEC(MM, theta=par1, x=x1, y=y1, alpha=0.05, method="Richardson",
            method.args=list(eps=1e-4, d=0.11, zero.tol=sqrt(.Machine$double.eps/7e-7), r=6, v=2)) 
res2
##################################################################################################


#### Example 2 ###################################################################################
# Development data of female pupae of cotton bollworm (Wu et al. 2009)
# References:
#   Ratkowsky, D.A. and Reddy, G.V.P. (2017) Empirical model with excellent statistical 
#       properties for describing temperature-dependent developmental rates of insects  
#       and mites. Ann. Entomol. Soc. Am. 110, 302-309.
#   Wu, K., Gong, P. and Ruan, Y. (2009) Estimating developmental rates of 
#       Helicoverpa armigera (Lepidoptera: Noctuidae) pupae at constant and
#       alternating temperature by nonlinear models. Acta Entomol. Sin. 52, 640-650.

# 'x2' is the vector of temperature (in degrees Celsius)
# 'D2' is the vector of developmental duration (in d)
# 'y2' is the vector of the square root of developmental rate (in 1/d)

x2 &lt;- seq(15, 37, by=1)
D2 &lt;- c( 41.24,37.16,32.47,26.22,22.71,19.01,16.79,15.63,14.27,12.48,
         11.3,10.56,9.69,9.14,8.24,8.02,7.43,7.27,7.35,7.49,7.63,7.9,10.03 )
y2 &lt;- 1/D2
y2 &lt;- sqrt( y2 )

# Define the square root function of the Lobry-Rosso-Flandrois (LRF) model
sqrt.LRF &lt;- function(P, x){
  ropt &lt;- P[1]
  Topt &lt;- P[2]
  Tmin &lt;- P[3]
  Tmax &lt;- P[4]
  fun0 &lt;- function(z){
    z[z &lt; Tmin] &lt;- Tmin
    z[z &gt; Tmax] &lt;- Tmax
    return(z)
  }
  x &lt;- fun0(x)
  if (Tmin &gt;= Tmax | ropt &lt;= 0 | Topt &lt;= Tmin | Topt &gt;= Tmax) 
    temp &lt;- Inf
  if (Tmax &gt; Tmin &amp; ropt &gt; 0 &amp; Topt &gt; Tmin &amp; Topt &lt; Tmax){
    temp &lt;- sqrt( ropt*(x-Tmax)*(x-Tmin)^2/((Topt-Tmin)*((Topt-Tmin
      )*(x-Topt)-(Topt-Tmax)*(Topt+Tmin-2*x))) )  
  }
  return( temp )
}

myfun &lt;- sqrt.LRF
par2  &lt;- c(0.1382926, 33.4575663, 5.5841244, 38.8282021)

# To calculate curvatures
resu2 &lt;- curvIPEC( myfun, theta=par2, x=x2, y=y2, alpha=0.05, method="Richardson", 
                   method.args=list(eps=1e-4, d=0.11, 
                   zero.tol=sqrt(.Machine$double.eps/7e-7), r=6, v=2) ) 
resu2
##################################################################################################


#### Example 3 ###################################################################################
# Height growth data of four species of bamboo (Gramineae: Bambusoideae)
# Reference(s):
# Shi, P., Fan, M., Ratkowsky, D.A., Huang, J., Wu, H., Chen, L., Fang, S. and  
#     Zhang, C. (2017) Comparison of two ontogenetic growth equations for animals and plants. 
#     Ecol. Model. 349, 1-10.

data(shoots)
# Choose a species
# 1: Phyllostachys iridescens; 2: Phyllostachys mannii; 
# 3: Pleioblastus maculatus; 4: Sinobambusa tootsik. 
# 'x3' is the vector of the investigation times (in d) from a specific starting time of growth
# 'y3' is the vector of the aboveground height values (in cm) of bamboo shoots at 'x3' 

ind &lt;- 4
x3  &lt;- shoots$x[shoots$Code == ind]
y3  &lt;- shoots$y[shoots$Code == ind] 

# Define the beta sigmoid model (bsm)
bsm &lt;- function(P, x){
  P  &lt;- cbind(P)
  if(length(P) !=4 ) {stop("The number of parameters should be 4!")}
  ropt &lt;- P[1]
  topt &lt;- P[2]
  tmin &lt;- P[3]
  tmax &lt;- P[4]
  tailor.fun &lt;- function(x){
    x[x &lt; tmin] &lt;- tmin
    x[x &gt; tmax] &lt;- tmax
    return(x)
  }
  x &lt;- tailor.fun(x)   
  ropt*(x-tmin)*(x-2*tmax+topt)/(topt+tmin-2*tmax)*(
     (x-tmin)/(topt-tmin))^((topt-tmin)/(tmax-topt))   
}

# Define the simplified beta sigmoid model (simp.bsm)
simp.bsm &lt;- function(P, x, tmin=0){
  P  &lt;- cbind(P)  
  ropt  &lt;- P[1]
  topt  &lt;- P[2]
  tmax  &lt;- P[3]
  tailor.fun &lt;- function(x){
    x[x &lt; tmin] &lt;- tmin
    x[x &gt; tmax] &lt;- tmax
    return(x)
  }
  x &lt;- tailor.fun(x)   
  ropt*(x-tmin)*(x-2*tmax+topt)/(topt+tmin-2*tmax)*(
  (x-tmin)/(topt-tmin))^((topt-tmin)/(tmax-topt))   
}

# For the original beta sigmoid model 
ini.val2 &lt;- c(40, 30, 5, 50)
xlab2    &lt;- "Time (d)"
ylab2    &lt;- "Height (cm)"
re0      &lt;- fitIPEC( bsm, x=x3, y=y3, ini.val=ini.val2, 
                     xlim=NULL, ylim=NULL, xlab=xlab2, ylab=ylab2, 
                     fig.opt=TRUE, control=list(trace=FALSE, reltol=1e-20, maxit=50000) )
par3  &lt;- re0$par
par3
re1   &lt;- derivIPEC( bsm, theta=par3, x3[20], method="Richardson", 
                    method.args=list(eps=1e-4, d=0.11, 
                    zero.tol=sqrt(.Machine$double.eps/7e-7), r=6, v=2) )
re1
re2   &lt;- curvIPEC( bsm, theta=par3, x=x3, y=y3, alpha=0.05, method="Richardson",                    
                   method.args=list(eps=1e-4, d=0.11, 
                   zero.tol=sqrt(.Machine$double.eps/7e-7), r=6, v=2) ) 
re2

# For the simplified beta sigmoid model (in comparison with the original beta sigmoid model)
ini.val7 &lt;- c(40, 30, 50)

RESU0 &lt;- fitIPEC( simp.bsm, x=x3, y=y3, ini.val=ini.val7, 
                  xlim=NULL, ylim=NULL, xlab=xlab2, ylab=ylab2, 
                  fig.opt=TRUE, control=list(trace=FALSE, reltol=1e-20, maxit=50000) )
par7  &lt;- RESU0$par
par7

RESU2 &lt;- curvIPEC( simp.bsm, theta=par7, x=x3, y=y3, alpha=0.05, method="Richardson",             
                   method.args=list(eps=1e-4, d=0.11, 
                   zero.tol=sqrt(.Machine$double.eps/7e-7), r=6, v=2) ) 
RESU2
##################################################################################################


#### Example 4 ###################################################################################
# Weight of cut grass data (Pattinson 1981)
# References:
#   Clarke, G.P.Y. (1987) Approximate confidence limits for a parameter function in nonlinear 
#       regression. J. Am. Stat. Assoc. 82, 221-230.
#   Gebremariam, B. (2014) Is nonlinear regression throwing you a curve? 
#       New diagnostic and inference tools in the NLIN Procedure. Paper SAS384-2014.
#       http://support.sas.com/resources/papers/proceedings14/SAS384-2014.pdf
#   Pattinson, N.B. (1981) Dry Matter Intake: An Estimate of the Animal
#       Response to Herbage on Offer. unpublished M.Sc. thesis, University
#       of Natal, Pietermaritzburg, South Africa, Department of Grassland Science.

# 'x4' is the vector of weeks after commencement of grazing in a pasture
# 'y4' is the vector of weight of cut grass from 10 randomly sited quadrants

x4 &lt;- 1:13
y4 &lt;- c(3.183, 3.059, 2.871, 2.622, 2.541, 2.184, 
        2.110, 2.075, 2.018, 1.903, 1.770, 1.762, 1.550)

# Define the first case of Mitscherlich equation
MitA &lt;- function(P1, x){
    P1[3] + P1[2]*exp(P1[1]*x)
}

# Define the second case of Mitscherlich equation
MitB &lt;- function(P2, x){
    log( P2[3] ) + exp(P2[2] + P2[1]*x)
}

# Define the third case of Mitscherlich equation
MitC &lt;- function(P3, x, x1=1, x2=13){
    theta1 &lt;- P3[1]
    beta2  &lt;- P3[2]
    beta3  &lt;- P3[3]
    theta2 &lt;- (beta3 - beta2)/(exp(theta1*x2)-exp(theta1*x1))
    theta3 &lt;- beta2/(1-exp(theta1*(x1-x2))) - beta3/(exp(theta1*(x2-x1))-1)
    theta3 + theta2*exp(theta1*x)
}

ini.val3 &lt;- c(-0.1, 2.5, 1)
r0       &lt;- fitIPEC( MitA, x=x4, y=y4, ini.val=ini.val3, xlim=NULL, ylim=NULL,  
                     fig.opt=TRUE, control=list(
                     trace=FALSE, reltol=1e-20, maxit=50000) )
parA     &lt;- r0$par
parA
r2 &lt;- curvIPEC( MitA, theta=parA, x=x4, y=y4, alpha=0.05, method="Richardson", 
                method.args=list(eps=1e-4, d=0.11, 
                zero.tol=sqrt(.Machine$double.eps/7e-7), r=6, v=2) ) 
r2

ini.val4 &lt;- c(exp(-0.1), log(2.5), 1)

R0       &lt;- fitIPEC( MitB, x=x4, y=y4, ini.val=ini.val3, xlim=NULL, ylim=NULL,  
                     fig.opt=TRUE, control=list(
                     trace=FALSE, reltol=1e-20, maxit=50000) )
parB     &lt;- R0$par
parB
R2       &lt;- curvIPEC( MitB, theta=parB, x=x4, y=y4, alpha=0.05, method="Richardson", 
                      method.args=list(eps=1e-4, d=0.11, 
                      zero.tol=sqrt(.Machine$double.eps/7e-7), r=6, v=2) ) 
R2

ini.val6 &lt;- c(-0.15, 2.52, 1.09)
RES0     &lt;- fitIPEC( MitC, x=x4, y=y4, ini.val=ini.val6, xlim=NULL, ylim=NULL,  
                     fig.opt=TRUE, control=list(trace=FALSE, 
                     reltol=1e-20, maxit=50000) )
parC     &lt;- RES0$par
parC
RES2     &lt;- curvIPEC( MitC, theta=parC, x=x4, y=y4, 
                      tol=1e-20, alpha=0.05, method="Richardson", 
                      method.args=list(eps=1e-4, d=0.11, 
                      zero.tol=sqrt(.Machine$double.eps/7e-7), r=6, v=2) ) 
RES2
##################################################################################################


#### Example 5 ###################################################################################
# Conductance of a thermistor (y5) as a function of temperature (x5) (Meyer and Roth, 1972)
# References:
#   Page 120 in Ratkowsky (1983)
#   Meyer, R.R. and Roth P.M. (1972) Modified damped least squares:
#       A algorithm for non-linear estimation. J. Inst. Math. Appl. 9, 218-233.

x5 &lt;- seq(50, 125, by=5)
y5 &lt;- c( 34780, 28610, 23650, 19630, 16370, 13720, 11540, 9744, 
         8261, 7030, 6005, 5147, 4427, 3820, 3307, 2872 )
y5 &lt;- log(y5)

conduct.fun &lt;- function(P, x){
-P[1]+P[2]/(x+P[3])
}

ini.val5 &lt;- c(5, 10^4, 0.5*10^3)
RE0      &lt;- fitIPEC( conduct.fun, x=x5, y=y5, ini.val=ini.val5, xlim=NULL, ylim=NULL,  
                     fig.opt=TRUE, control=list(
                     trace=FALSE, reltol=1e-20, maxit=50000) )
par5     &lt;- RE0$par
par5
RE2      &lt;- curvIPEC( conduct.fun, theta=par5, x=x5, y=y5, alpha=0.05, method="Richardson", 
                      method.args=list(eps=1e-4, d=0.11, 
                      zero.tol=sqrt(.Machine$double.eps/7e-7), r=6, v=2) ) 
RE2
##################################################################################################


#### Example 6 ###################################################################################
# Data on biochemical oxygen demand (BOD; Marske 1967)
# References
# Pages 255 and 270 in Bates and Watts (1988)
# Marske, D. (1967) Biochemical oxygen demand data interpretation using sum of squares surface.
#     M.Sc. Thesis, University of Wisconsin-Madison.

# 'x6' is a vector of time (in d)
# 'y6' is a vector of biochemical oxygen demand (mg/l)

x6 &lt;- c(1, 2, 3, 4, 5, 7)
y6 &lt;- c(8.3, 10.3, 19.0, 16.0, 15.6, 19.8)

BOD.fun &lt;- function(P, x){
  P[1]*(1-exp(P[2]*x))
}

ini.val7 &lt;- c(210, 0.06)
consq0   &lt;- fitIPEC( BOD.fun, x=x6, y=y6, ini.val=ini.val7, xlim=NULL, ylim=NULL,  
                     fig.opt=TRUE, control=list(
                     trace=FALSE, reltol=1e-20, maxit=50000) )
par7     &lt;- consq0$par
par7
consq2   &lt;- curvIPEC( BOD.fun, theta=par7, x=x6, y=y6, alpha=0.05, method="Richardson", 
                      method.args=list(eps=1e-4, d=0.11, 
                      zero.tol=sqrt(.Machine$double.eps/7e-7), r=6, v=2) ) 
consq2
##################################################################################################


#### Example 7 ###################################################################################
# Data on biochemical oxygen demand (BOD; Marske 1967)
# References:
# Pages 56, 255 and 271 in Bates and Watts (1988)
# Carr, N.L. (1960) Kinetics of catalytic isomerization of n-pentane. Ind. Eng. Chem.
#     52, 391-396.   

data(isom)
Y &lt;- isom[,1]
X &lt;- isom[,2:4]

# There are three independent variables saved in matrix 'X' and one response variable (Y)
# The first column of 'X' is the vector of partial pressure of hydrogen
# The second column of 'X' is the vector of partial pressure of n-pentane
# The third column of 'X' is the vector of partial pressure of isopentane
# Y is the vector of experimental reaction rate (in 1/hr)

isom.fun &lt;- function(theta, x){
  x1     &lt;- x[,1]
  x2     &lt;- x[,2]
  x3     &lt;- x[,3]
  theta1 &lt;- theta[1]
  theta2 &lt;- theta[2]
  theta3 &lt;- theta[3]
  theta4 &lt;- theta[4]
  theta1*theta3*(x2-x3/1.632) / ( 1 + theta2*x1 + theta3*x2 + theta4*x3 )
}

par8  &lt;- c(35.92831619, 0.07084811, 0.03772270, 0.16718384) 
cons2 &lt;- curvIPEC( isom.fun, theta=par8, x=X, y=Y, alpha=0.05, method="Richardson", 
                   method.args=list(eps=1e-4, d=0.11, 
                   zero.tol=sqrt(.Machine$double.eps/7e-7), r=6, v=2) ) 
cons2
##################################################################################################
</code></pre>


</div>