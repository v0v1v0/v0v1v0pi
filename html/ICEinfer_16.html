<div class="container">

<table style="width: 100%;"><tr>
<td>ICEscale</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>
ICEscale() functions compute or print ICE Statistical Inference Summary Statistics
relative to choice for the numerical value of the Shadow Price of Health, lambda
</h2>

<h3>Description</h3>

<p>ICEscale() computes Summary Statistics for 2-sample, 2-variable inference where one variable
is a measure of effectiveness (higher values are better) and the other variable is a measure
of cost (lower values are better).  The 2 samples are of patients receiving only 1 of the 2
possible treatments.  The treatment called new is the one with the higher numerical level
for the specified treatment indicator variable, while the treatment called std corresponds
to the lower numerical level.  The pivotal statistic for inference is (DeltaEffe, DeltaCost),
which are the head-to-head mean differences for new treatment minus std treatment.  Each
sample is assumed to provide unbiased estimates of the overall expected effectiveness and cost
for that treatment.
</p>


<h3>Usage</h3>

<pre><code class="language-R">ICEscale(df, trtm, xeffe, ycost, lambda = 1, ceunit = "cost")
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>df</code></td>
<td>
<p>Required; Existing data.frame object containing the trtm, xeffe and ycost variables.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>trtm</code></td>
<td>
<p>Required; Name of the treatment indicator variable contained within the df
data.frame that assumes one of only two different numerical values for each patient.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>xeffe</code></td>
<td>
<p>Required; Name of the treatment effectiveness variable within the df data.frame.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ycost</code></td>
<td>
<p>Required; Name of the treatment cost variable within the df data.frame.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lambda</code></td>
<td>
<p>Optional; <code>lambda</code> strictly positive value for the Shadow Price of Health.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ceunit</code></td>
<td>
<p>Optional; <code>ceunit</code> character string containing either cost (default) or effe.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>After an initial call with the default value of lambda = 1, multiple additional calls to
ICEscale() with different numerical values for lambda are usually made at the very beginning of
analyses using other functions from the ICEinfer package.  For example, the statistical
choice for lambda assures that the DeltaEffe and DeltaCost mean treatment differences (new
minus std) will have approximately equal variability when expressed in either cost or
effe ceunits.  The power of ten value of lambda that is closest to the statistical value
for lambda assures use of ceunits that, except for the position of the decimal point, are identical
to the cost/effectiveness ratio implied by the scales in which data values are stored within
the input data.frame.
</p>


<h3>Value</h3>

<p>Object of class ICEscale containing an output list with the following items:
</p>
<table>
<tr style="vertical-align: top;">
<td><code>trtm</code></td>
<td>
<p>Saved name of the treatment indicator within the input data.frame.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>xeffe</code></td>
<td>
<p>Saved name of the treatment effectiveness variable within the input data.frame.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>ycost</code></td>
<td>
<p>Saved name of the treatment cost variable within the input data.frame.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>effcst</code></td>
<td>
<p>Saved value of the sorted 3-variable (trtm,effe,cost) data.frame.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lambda</code></td>
<td>
<p>Value for the Shadow Price of Health, lambda, input to ICEscals().</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>t1</code></td>
<td>
<p>Observed values of (DeltaEffe, DeltaCost) when each distinct patient is sampled
exactly once.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>s1</code></td>
<td>
<p>Observed values for the standard deviations of (DeltaEffe, DeltaCost) when each
distinct patient is sampled exactly once.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>slam</code></td>
<td>
<p>Statistical Shadow Price computed as s1[2]/s1[1] and rounded to digits = 3.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>potlam</code></td>
<td>
<p>Power-of-Ten Shadow Price computed as 10\^(as.integer(log10(slam))).</p>
</td>
</tr>
</table>
<h3>Author(s)</h3>

<p>Bob Obenchain &lt;wizbob@att.net&gt;</p>


<h3>References</h3>

<p>Obenchain RL.  Issues and algorithms in cost-effectiveness inference.  <em>Biopharmaceutical
Reports</em> 1997; <b>5(2)</b>: 1-7.  Washington, DC: American Statistical Association.
</p>
<p>Cook JR, Heyse JF.  Use of an angular transformation for ratio estimation in cost-effectiveness
analysis.  <em>Statistics in Medicine</em>  2000; <b>19</b>: 2989-3003.
</p>


<h3>See Also</h3>

<p><code>ICEscale</code>, <code>plot.ICEuncrt</code> and <code>print.ICEuncrt</code></p>


<h3>Examples</h3>

<pre><code class="language-R">  data(dulxparx)
  ICEscale(dulxparx, dulx, idb, ru)
</code></pre>


</div>