<div class="container">

<table style="width: 100%;"><tr>
<td>k_shortest_paths</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Find the <code class="reqn">k</code> shortest paths between two vertices</h2>

<h3>Description</h3>

<p>Finds the <code class="reqn">k</code> shortest paths between the given source and target
vertex in order of increasing length. Currently this function uses
Yen's algorithm.
</p>


<h3>Usage</h3>

<pre><code class="language-R">k_shortest_paths(
  graph,
  from,
  to,
  ...,
  k,
  weights = NULL,
  mode = c("out", "in", "all", "total")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>graph</code></td>
<td>
<p>The input graph.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>from</code></td>
<td>
<p>The source vertex of the shortest paths.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>to</code></td>
<td>
<p>The target vertex of the shortest paths.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>These dots are for future extensions and must be empty.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>k</code></td>
<td>
<p>The number of paths to find. They will be returned in order of
increasing length.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>weights</code></td>
<td>
<p>Possibly a numeric vector giving edge weights. If this is
<code>NULL</code> and the graph has a <code>weight</code> edge attribute, then the
attribute is used. If this is <code>NA</code> then no weights are used (even if
the graph has a <code>weight</code> attribute). In a weighted graph, the length
of a path is the sum of the weights of its constituent edges.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>mode</code></td>
<td>
<p>Character constant, gives whether the shortest paths to or from
the given vertices should be calculated for directed graphs. If <code>out</code>
then the shortest paths <em>from</em> the vertex, if <code style="white-space: pre;">⁠in⁠</code> then <em>to</em>
it will be considered. If <code>all</code>, the default, then the graph is treated
as undirected, i.e. edge directions are not taken into account. This
argument is ignored for undirected graphs.</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p>A named list with two components is returned:
</p>
<table>
<tr style="vertical-align: top;">
<td><code>vpaths</code></td>
<td>
<p>The list of <code class="reqn">k</code> shortest paths in terms of vertices</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>epaths</code></td>
<td>
<p>The list of <code class="reqn">k</code> shortest paths in terms of edges</p>
</td>
</tr>
</table>
<h3>Related documentation in the C library</h3>

<p><a href="https://igraph.org/c/html/latest/igraph-Structural.html#igraph_get_k_shortest_paths"><code>igraph_get_k_shortest_paths()</code></a>.</p>


<h3>References</h3>

<p>Yen, Jin Y.:
An algorithm for finding shortest routes from all source nodes to a given
destination in general networks.
Quarterly of Applied Mathematics. 27 (4): 526–530. (1970)
<a href="https://doi.org/10.1090/qam/253822">doi:10.1090/qam/253822</a>
</p>


<h3>See Also</h3>

<p><code>shortest_paths()</code>, <code>all_shortest_paths()</code>
</p>
<p>Other structural.properties: 
<code>bfs()</code>,
<code>component_distribution()</code>,
<code>connect()</code>,
<code>constraint()</code>,
<code>coreness()</code>,
<code>degree()</code>,
<code>dfs()</code>,
<code>distance_table()</code>,
<code>edge_density()</code>,
<code>feedback_arc_set()</code>,
<code>girth()</code>,
<code>is_acyclic()</code>,
<code>is_dag()</code>,
<code>is_matching()</code>,
<code>knn()</code>,
<code>reciprocity()</code>,
<code>subcomponent()</code>,
<code>subgraph()</code>,
<code>topo_sort()</code>,
<code>transitivity()</code>,
<code>unfold_tree()</code>,
<code>which_multiple()</code>,
<code>which_mutual()</code>
</p>


</div>